%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}




\title{open source watch Documentation}
\date{Jan 04, 2021}
\release{1.1.0}
\author{jj}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\noindent\sphinxincludegraphics{{zephyr_logo}.png}




\chapter{Copyright}
\label{\detokenize{copyright:copyright}}\label{\detokenize{copyright::doc}}
\sphinxstylestrong{Note : You may at any time read the book, store it in your ereaders}

The book itself is subject to copyright.

You cannot use the book, or parts of the book into your own publications, without the permission of the author.


\section{author:}
\label{\detokenize{copyright:author}}
Jan Jansen
\sphinxhref{mailto:najnesnaj@yahoo.com}{najnesnaj@yahoo.com}


\section{LICENSE:}
\label{\detokenize{copyright:license}}
All the software is subject to the Apache 2.0 license (same as zephyr), which is very liberal.


\chapter{Zephyr for the pinetime smartwatch}
\label{\detokenize{content:zephyr-for-the-pinetime-smartwatch}}\label{\detokenize{content::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{this} \PYG{n}{document} \PYG{n}{describes} \PYG{n}{the} \PYG{n}{installation} \PYG{n}{of} \PYG{n}{zephyr} \PYG{n}{RTOS} \PYG{n}{on} \PYG{n}{the} \PYG{n}{PineTime} \PYG{n}{smartwatch}\PYG{o}{.}

\PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{wiki}\PYG{o}{.}\PYG{n}{pine64}\PYG{o}{.}\PYG{n}{org}\PYG{o}{/}\PYG{n}{index}\PYG{o}{.}\PYG{n}{php}\PYG{o}{/}\PYG{n}{PineTime}

\PYG{n}{It} \PYG{n}{should} \PYG{n}{be} \PYG{n}{applicable} \PYG{n}{on} \PYG{n}{other} \PYG{n}{nordic} \PYG{n}{nrf52832} \PYG{n}{based} \PYG{n}{watches} \PYG{p}{(}\PYG{n}{Desay} \PYG{n}{D6}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{the} \PYG{n}{approach} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{manual} \PYG{o+ow}{is} \PYG{n}{to} \PYG{n}{get} \PYG{n}{quick} \PYG{n}{results} \PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{n}{minimal} \PYG{n}{effort} \PYG{n}{install} \PYG{p}{(}\PYG{n}{pinetime} \PYG{n}{works} \PYG{k}{as} \PYG{n}{an} \PYG{n}{external} \PYG{p}{(}\PYG{n}{out} \PYG{n}{of} \PYG{n}{tree}\PYG{p}{)}
      \PYG{n}{application} \PYG{k}{for} \PYG{n}{zephyr}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{k}{try} \PYG{n}{out} \PYG{n}{the} \PYG{n}{samples}
    \PYG{o}{\PYGZhy{}} \PYG{n}{inspire} \PYG{n}{you} \PYG{n}{to} \PYG{n}{modify} \PYG{o+ow}{and} \PYG{n}{enhance}
\end{sphinxVerbatim}
\begin{description}
\item[{suggestion :}] \leavevmode\begin{itemize}
\item {} 
follow the installation instructions

\item {} 
try some examples

\item {} 
try out bluetooth

\item {} 
try out the display

\end{itemize}

\end{description}

\noindent\sphinxincludegraphics{{PineTime-830x400}.png}


\chapter{Install zephyr}
\label{\detokenize{installation:install-zephyr}}\label{\detokenize{installation::doc}}

\section{update on 31\sphinxhyphen{}12\sphinxhyphen{}2020}
\label{\detokenize{installation:update-on-31-12-2020}}
Pinetime has become part of the standard zephyr distribution!
This manual was initially created with Pinetime as an external application.
As from today you can install zephyr and execute a pinetime sample!

However the drivers for the Heartrate sensor, accell sensor and touch screen are not \sphinxhyphen{} yet \sphinxhyphen{} part of the standard zephyr\sphinxhyphen{}distribution.
These drivers are work in progress.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{pinetime\PYGZus{}devkit0} \PYG{n}{samples}\PYG{o}{/}\PYG{n}{boards}\PYG{o}{/}\PYG{n}{pine64\PYGZus{}pinetime}
\end{sphinxVerbatim}


\section{In case you already have zephyr installed:}
\label{\detokenize{installation:in-case-you-already-have-zephyr-installed}}
Pinetime works as external (out of tree) application.
You can clone pinetime next to zephyr in the working directory and update manifest and west.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{west} \PYG{n}{config} \PYG{n}{manifest}\PYG{o}{.}\PYG{n}{path} \PYG{n}{pinetime}
\end{sphinxVerbatim}


\section{In case you start from scratch :}
\label{\detokenize{installation:in-case-you-start-from-scratch}}
\sphinxurl{https://docs.zephyrproject.org/latest/getting\_started/index.html}

the documentation describes an installation process under Ubuntu/macOS/Windows

I picked Debian (which is not listed)
…. and soon afterwards ran into trouble

\sphinxtitleref{this behaviour is known as : stuborn or stupid, but I remain convinced it could work}

In the Zephyr getting started page :
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
select and update OS

\item {} 
install dependencies

\item {} 
Get the source code

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{instead} \PYG{n}{of} \PYG{n}{following} \PYG{n}{the} \PYG{n}{procedure}\PYG{p}{:}
       \PYG{n}{cd} \PYG{o}{\PYGZti{}}
       \PYG{n}{west} \PYG{n}{init} \PYG{n}{zephyrproject}
       \PYG{n}{cd} \PYG{n}{zephyrproject}
       \PYG{n}{west} \PYG{n}{update}

\PYG{n}{you} \PYG{n}{should} \PYG{n}{do} \PYG{n}{this} \PYG{p}{:}
        \PYG{n}{cd} \PYG{o}{\PYGZti{}}
        \PYG{n}{mkdir} \PYG{n}{work}
        \PYG{n}{cd} \PYG{n}{work}
        \PYG{n}{west} \PYG{n}{init} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{najnesnaj}\PYG{o}{/}\PYG{n}{pinetime}\PYG{o}{\PYGZhy{}}\PYG{n}{zephyr}
        \PYG{n}{west} \PYG{n}{update}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{3}
\item {} 
complete the other steps

\end{enumerate}

to test if your install works :

cd \textasciitilde{}/work/pinetime

west build \sphinxhyphen{}p \sphinxhyphen{}b pinetime samples/basic/blinky

\sphinxstylestrong{TIP : sometimes you run into trouble compiling: removing the build directory can help in that case}


\chapter{Starting with some basic applications}
\label{\detokenize{basicapplications:starting-with-some-basic-applications}}\label{\detokenize{basicapplications::doc}}
The best way to get a feel of zephyr for the PineTime watch, is to start building applications.

The gpio ports, i2c communication, memory layout, stuff that is particular for the watch is defined in the board definition file.

The provided samples are standard zephyr application, with some minor modifications.


\section{Blinky    example}
\label{\detokenize{basicapplications:blinky-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{watch} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{contain} \PYG{n}{a} \PYG{n}{led} \PYG{k}{as} \PYG{n}{such}\PYG{p}{,} \PYG{n}{but} \PYG{n}{it} \PYG{n}{has} \PYG{n}{background} \PYG{n}{leds} \PYG{k}{for} \PYG{n}{the} \PYG{n}{LCD}\PYG{o}{.}

\PYG{n}{Once} \PYG{n}{lit}\PYG{p}{,} \PYG{n}{you} \PYG{n}{can} \PYG{n}{barely} \PYG{n}{see} \PYG{n}{it}\PYG{p}{,} \PYG{n}{cause} \PYG{n}{the} \PYG{n}{screen}\PYG{o}{\PYGZhy{}}\PYG{n}{LCD} \PYG{n}{remains} \PYG{n}{black}\PYG{o}{.}

\PYG{n}{The} \PYG{n}{screen} \PYG{n}{contains} \PYG{n}{three} \PYG{n}{leds}\PYG{p}{,} \PYG{n}{this} \PYG{n}{way} \PYG{n}{the} \PYG{n}{intensity} \PYG{o+ow}{is} \PYG{n+nb}{set}\PYG{o}{.}
\end{sphinxVerbatim}

have a look at the pinetime.dts file, here you see the definition of the background leds.

\sphinxtitleref{building an image, which can be found under the build directory}

see : {\hyperref[\detokenize{samples/basic/blinky/README:blinky-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{Blinky Application}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}p \PYGZhy{}b pinetime samples/basic/blinky
\end{sphinxVerbatim}

once the compilation is completed,  you can find the firmware under :
\textasciitilde{}/work/pinetime/build/zephyr/zephyr.bin


\section{Reading out the button on the watch}
\label{\detokenize{basicapplications:reading-out-the-button-on-the-watch}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{n}{have} \PYG{n}{a} \PYG{n}{button} \PYG{n}{on} \PYG{n}{the} \PYG{n}{side}\PYG{o}{.}

\PYG{n}{In} \PYG{n}{order} \PYG{n}{to} \PYG{n}{check} \PYG{k}{if} \PYG{n}{the} \PYG{n}{button} \PYG{o+ow}{is} \PYG{n}{pressed}\PYG{p}{,} \PYG{n}{it} \PYG{n}{sets} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{basicapplications:building-and-running}}
see : {\hyperref[\detokenize{samples/basic/button/README:button-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{Button demo}}}}

\sphinxstyleemphasis{Note:}:
\sphinxtitleref{The watch has a button out port (15) and button in port (13). You have to set the out\sphinxhyphen{}port high. Took me a while to figure this out…}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/basic/button}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=(read button value);

this way you know till whether the code executes
\end{sphinxadmonition}

a way to set port 15 high (hard\sphinxhyphen{}coded of course :))

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{gpio\PYGZus{}pin\PYGZus{}configure(gpiob, 15,GPIO\PYGZus{}DIR\PYGZus{}OUT); //push button out}
\PYG{g+go}{gpio\PYGZus{}pin\PYGZus{}write(gpiob, 15, \PYGZam{}button\PYGZus{}out); //set port high}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

Peeking

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1
\PYG{g+go}{0x2000f000: 00000100 (switch pushed)}
\end{sphinxVerbatim}


\chapter{bluetooth (BLE) example}
\label{\detokenize{bluetooth:bluetooth-ble-example}}\label{\detokenize{bluetooth::doc}}
The PineTime uses a Nordic nrf52832 chip, which has BLE functionality build into it.

To test, you can compile a standard application : Eddy Stone.

The watch will behave as a bluetooth beacon, and you should be able to detect it with your smartphone or with bluez under linux.


\section{Using a standard zephyr application under pinetime:}
\label{\detokenize{bluetooth:using-a-standard-zephyr-application-under-pinetime}}
Each sample has its own directory.
In this directory you will notice a file : “CMakeLists.txt”.

In order to use a standard, you can just copy it under the pinetime directory.

In order to be able to compile it, you just have to add one line in the CMakeList.txt :

\sphinxtitleref{include(\$ENV\{ZEPHYR\_BASE\}/../pinetime/cmake/boilerplate.cmake)}

Have a look in the samples/bluetooth/eddystone directory.


\section{Eddy Stone}
\label{\detokenize{bluetooth:eddy-stone}}\begin{quote}

see:   {\hyperref[\detokenize{samples/bluetooth/eddystone/README:bluetooth-eddystone-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{Bluetooth: Eddystone}}}}
\end{quote}

\sphinxstylestrong{Note:}  compile the provided example, so a build directory gets created

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/eddystone
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{this builds an image, which can be found under the build directory}}


\section{Using the created bluetooth sample:}
\label{\detokenize{bluetooth:using-the-created-bluetooth-sample}}
I use linux with a bluetoothadapter 4.0.
You need to install bluez.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on
\end{sphinxVerbatim}

And your Eddy Stone should be visible.

If you have a smartphone, you can download the nrf utilities app from nordic.


\section{Ble Peripheral}
\label{\detokenize{bluetooth:ble-peripheral}}
this example is a demo of the services under bluetooth

first build the image

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral
\end{sphinxVerbatim}

With linux you can have a look using bluetoothctl:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on


\PYG{g+go}{[NEW] Device 60:7C:9E:92:50:C1 Zephyr Peripheral Sample Long}
\PYG{g+go}{once you see your device}
\PYG{g+gp}{[blueooth]\PYGZsh{}}connect \PYG{l+m}{60}:7C:9E:92:50:C1 \PYG{o}{(}the device mac address as displayed\PYG{o}{)}

\PYG{g+go}{then you can already see the services}
\end{sphinxVerbatim}

same thing with the app from nordic, you could try to connect and display value of e.g. heart rate


\section{using Python to read out bluetoothservices}
\label{\detokenize{bluetooth:using-python-to-read-out-bluetoothservices}}
In this repo you will find a python script : readbat.py
In order to use it you need bluez on linux and the python \sphinxtitleref{bluepy} module.

It can be used in conjunction with the peripheral bluetooth demo.
It just reads out the battery level, and prints it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{binascii}
\PYG{k+kn}{from} \PYG{n+nn}{bluepy}\PYG{n+nn}{.}\PYG{n+nn}{btle} \PYG{k+kn}{import} \PYG{n}{UUID}\PYG{p}{,} \PYG{n}{Peripheral}

\PYG{n}{temp\PYGZus{}uuid} \PYG{o}{=} \PYG{n}{UUID}\PYG{p}{(}\PYG{l+m+mh}{0x2A19}\PYG{p}{)}

\PYG{n}{p} \PYG{o}{=} \PYG{n}{Peripheral}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{60:7C:9E:92:50:C1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{random}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{try}\PYG{p}{:}
   \PYG{n}{ch} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{getCharacteristics}\PYG{p}{(}\PYG{n}{uuid}\PYG{o}{=}\PYG{n}{temp\PYGZus{}uuid}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
   \PYG{n+nb}{print} \PYG{n}{binascii}\PYG{o}{.}\PYG{n}{b2a\PYGZus{}hex}\PYG{p}{(}\PYG{n}{ch}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{finally}\PYG{p}{:}
    \PYG{n}{p}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{display (st7789)}
\label{\detokenize{display:display-st7789}}\label{\detokenize{display:display-sample}}\label{\detokenize{display::doc}}

\section{Display    example}
\label{\detokenize{display:display-example}}
This is just a simple display test.
It displays coloured squares, but it allows you to check if the screen is OK.

\sphinxstylestrong{TIP: While connecting 5V, do not connect 3.3V at the same time}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{watch} \PYG{n}{has} \PYG{n}{background} \PYG{n}{leds} \PYG{k}{for} \PYG{n}{the} \PYG{n}{LCD}\PYG{o}{.}

\PYG{n}{They} \PYG{n}{need} \PYG{n}{to} \PYG{n}{be} \PYG{n}{on} \PYG{p}{(}\PYG{n}{LOW}\PYG{p}{)} \PYG{n}{to} \PYG{n}{visualize} \PYG{n}{the} \PYG{n}{display}\PYG{o}{.}
\PYG{n}{Have} \PYG{n}{a} \PYG{n}{look} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{source} \PYG{n}{code}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/display/st7789v
\end{sphinxVerbatim}

Once the compilation is completed you can upload the firmware.

If all goes well, you should see some coloured squares on your screen.

\sphinxstylestrong{Note : in order to get the display st7789 Picture\sphinxhyphen{}Perfect, you might need a zephyr patch}

have a look at : \sphinxurl{https://github.com/zephyrproject-rtos/zephyr/pull/20570/files}
You will find them in this repo under patches\sphinxhyphen{}zephyr.


\chapter{GFX Library Sample}
\label{\detokenize{gfx:gfx-library-sample}}\label{\detokenize{gfx:gfx-sample}}\label{\detokenize{gfx::doc}}

\section{Overview}
\label{\detokenize{gfx:overview}}
This sample is built on top of the ST7789 display sample ({\hyperref[\detokenize{display:display-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{display (st7789)}}}}), extending it with the \sphinxhref{https://github.com/adafruit/Adafruit-GFX-Library}{Adafruit GFX Library}.
The library was ported from Arduino and has the same functionality and API.
See \sphinxcode{\sphinxupquote{src/main.cpp}} for examples on the GFX API usage.

See {\hyperref[\detokenize{display:display-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{display (st7789)}}}} for more details on working with the display itself.


\section{Usage}
\label{\detokenize{gfx:usage}}
Add the gfx sample from this repo into your project:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} cp samples/gui/gfx \PYGZti{}/zephyrproject/zephyr/samples/gui/
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
In order to make the library work the sample is built with C++ support. This is achieved by having the following line in the sample’s \sphinxtitleref{prj.conf} configuration:

\sphinxcode{\sphinxupquote{CONFIG\_CPLUSPLUS=y}}
\end{sphinxadmonition}

Build \& flash the sample:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/gfx
\PYG{g+gp}{\PYGZdl{}}  west flash
\end{sphinxVerbatim}

If all goes well, you should see a looping graphical test: drawing lines, rectangles, triangles etc.


\chapter{LittlevGL Basic Sample}
\label{\detokenize{lvgl:littlevgl-basic-sample}}\label{\detokenize{lvgl:lvgl-sample}}\label{\detokenize{lvgl::doc}}

\section{Overview}
\label{\detokenize{lvgl:overview}}
This sample application displays “Hello World” in the center of the screen
and a counter at the bottom which increments every second.

LittlevGL is a free and open\sphinxhyphen{}source graphics library providing everything you need to create embedded GUI with easy\sphinxhyphen{}to\sphinxhyphen{}use graphical elements, beautiful visual effects and low memory footprint.


\section{Requirements}
\label{\detokenize{lvgl:requirements}}
The program has been modified to light up the background leds.

\sphinxstylestrong{TIP: matching label : DISPLAY}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Matching labels are necessary!
pinetime.conf:CONFIG\PYGZus{}LVGL\PYGZus{}DISPLAY\PYGZus{}DEV\PYGZus{}NAME=\PYGZdq{}DISPLAY\PYGZdq{}
pinetime.overlay:               label = \PYGZdq{}DISPLAY\PYGZdq{}; (spi definition)
\end{sphinxVerbatim}


\section{Building and Running}
\label{\detokenize{lvgl:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/lvgl}
\end{sphinxVerbatim}


\subsection{modifying the font size :}
\label{\detokenize{lvgl:modifying-the-font-size}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}t menuconfig}
\end{sphinxVerbatim}
\begin{description}
\item[{goto:}] \leavevmode\begin{itemize}
\item {} 
additional libraries

\item {} 
lvgl gui library

\end{itemize}

(look for fonts, and adapt according to your need)

\end{description}


\subsection{apply changes of the changed config:}
\label{\detokenize{lvgl:apply-changes-of-the-changed-config}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build}
\end{sphinxVerbatim}

(instead of west build \sphinxhyphen{}p (pristine) which wipes out your customisation)


\section{Todo}
\label{\detokenize{lvgl:todo}}\begin{itemize}
\item {} 
Create a button

\item {} 
touchscreen activation (problem cause zephyr does not support this yet)

\item {} 
lvgl supports lv\_canvas\_rotate(canvas, \&imd\_dsc, angle, x, y, pivot\_x, pivot\_y) should be cool for a clock, chrono…

\end{itemize}


\section{References}
\label{\detokenize{lvgl:references}}
\sphinxurl{https://docs.littlevgl.com/en/html/index.html}

LittlevGL Web Page: \sphinxurl{https://littlevgl.com/}


\chapter{LittlevGL Clock Sample}
\label{\detokenize{clock:littlevgl-clock-sample}}\label{\detokenize{clock:lvgl-clock}}\label{\detokenize{clock::doc}}
see : {\hyperref[\detokenize{samples/gui/clock/README:clock-sample}]{\sphinxcrossref{\DUrole{std,std-ref}{LittlevGL Clock Sample}}}}


\section{Overview}
\label{\detokenize{clock:overview}}
This sample application displays a “clockbackground” in the center of the screen.

LittlevGL is a free and open\sphinxhyphen{}source graphics library providing everything you need to create embedded GUI with easy\sphinxhyphen{}to\sphinxhyphen{}use graphical elements, beautiful visual effects and low memory footprint.

\noindent\sphinxincludegraphics{{clockback}.png}


\section{Requirements}
\label{\detokenize{clock:requirements}}
Make sure the prj.conf contains the following :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONFIG\PYGZus{}LVGL}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}LVGL\PYGZus{}OBJ\PYGZus{}IMAGE}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}

LitlevGL uses a “c” file to store the image.
You need to convert a jpg, or png image to this c file.
There is an online tool : \sphinxurl{https://littlevgl.com/image-to-c-array}


\section{Building and Running}
\label{\detokenize{clock:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/clock}
\end{sphinxVerbatim}


\section{Todo}
\label{\detokenize{clock:todo}}\begin{itemize}
\item {} 
create an internal clock (and adjustment mechanism, eg. bluetooth cts)

\item {} 
lvgl supports lv\_canvas\_rotate(canvas, \&imd\_dsc, angle, x, y, pivot\_x, pivot\_y) should be cool for a clock, chrono…

\end{itemize}


\section{References}
\label{\detokenize{clock:references}}
\sphinxurl{https://docs.littlevgl.com/en/html/index.html}

LittlevGL Web Page: \sphinxurl{https://littlevgl.com/}


\chapter{Real Time Clock}
\label{\detokenize{RTC:real-time-clock}}\label{\detokenize{RTC:rtc}}\label{\detokenize{RTC::doc}}

\section{Overview}
\label{\detokenize{RTC:overview}}
This sample application “clock” uses the RTC2 timer.
(the standard sample with RTC0 is not usable together with bluetooth)

It uses the counter driver. (based on the alarm sample)

Basically an interrupt is set to go off after 1 second.
The number of seconds is incremented and the interrupt is launched again.

It will serve as a building block for a “time of the day” clock.

In addition it will need a function to set the time.

In bluetooth one can use CTS (central time service)

{\color{red}\bfseries{}**}NOTE: as I found out there is a conflict between RTC0 and bluetooth **


\section{Requirements}
\label{\detokenize{RTC:requirements}}
Make sure the prj.conf contains the following :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONFIG\PYGZus{}COUNTER}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}


\section{Building and Running}
\label{\detokenize{RTC:building-and-running}}

\section{Todo}
\label{\detokenize{RTC:todo}}\begin{itemize}
\item {} 
time of day clock

\item {} 
setting the time

\end{itemize}


\section{References}
\label{\detokenize{RTC:references}}

\chapter{Current Time Service}
\label{\detokenize{current-time:current-time-service}}\label{\detokenize{current-time::doc}}
\sphinxurl{https://www.bluetooth.com/specifications/gatt/services/}
\sphinxurl{https://www.bluetooth.com/specifications/gatt/characteristics/}
0x1805 current time service
0x2A2B current time characteristic


\section{Requirements:}
\label{\detokenize{current-time:requirements}}\begin{description}
\item[{You need :}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{a CTS server (use of bluez on linux explained)}] \leavevmode\begin{itemize}
\item {} 
start the CTS service (python script)

\item {} 
connect to the CTS client

\end{itemize}

\end{description}

\item {} 
a CTS client (the pinetime watch)

\end{itemize}

\end{description}


\section{BLE Peripheral CTS sample for zephyr}
\label{\detokenize{current-time:ble-peripheral-cts-sample-for-zephyr}}
This example demonstrates the basic usage of the current time service.
It is based on the \sphinxurl{https://github.com/Dejvino/pinetime-hermes-firmware}.
It starts advertising it’s UUID, and you can connect to it.
Once connected, it will read the time from your CTS server (bluez on linux running the gatt\sphinxhyphen{}cts\sphinxhyphen{}server script in my case)

first build the image

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}}  west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral\PYGZhy{}cts
\end{sphinxVerbatim}


\section{Using bluez on linux to connect}
\label{\detokenize{current-time:using-bluez-on-linux-to-connect}}\begin{description}
\item[{The pinetime zephyr sample behaves as a peripheral:}] \leavevmode\begin{itemize}
\item {} 
first of all start the cts service

\end{itemize}
\begin{quote}

\sphinxhyphen{}connect to the pinetime with bluetoothctl
\end{quote}

\end{description}

Using bluetoothctl:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}bluetoothctl
\PYG{g+gp}{[bluetooth]\PYGZsh{}}scan on


\PYG{g+go}{[NEW] Device 60:7C:9E:92:50:C1 Zephyr Peripheral Sample Long}
\PYG{g+go}{once you see your device}
\PYG{g+gp}{[blueooth]\PYGZsh{}}connect \PYG{l+m}{60}:7C:9E:92:50:C1 \PYG{o}{(}the device mac address as displayed\PYG{o}{)}
\end{sphinxVerbatim}


\section{Howto use Bluez on linux to set up a time service}
\label{\detokenize{current-time:howto-use-bluez-on-linux-to-set-up-a-time-service}}
Within the bluez source distribution there is an example GATT (Generic Attribute Profile)server. It advertises some standard service such as heart rate, battery …
Koen zandberg adapted this script, so it advertises the current time :
\sphinxurl{https://github.com/bosmoment/gatt-cts/blob/master/gatt-cts-server.py}

You might have to install extra packages:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}dbus}
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}gi}
\PYG{g+go}{apt\PYGZhy{}get install python\PYGZhy{}gobject}
\end{sphinxVerbatim}


\section{Howto use Android to set up a time service}
\label{\detokenize{current-time:howto-use-android-to-set-up-a-time-service}}
As soon as a device is bonded, Pinetime will look for a CTS server (Current Time Service) on the connected device.
Here is how to do it with an Android smartphone running NRFConnect:

Build and program the firmware on the Pinetime Install NRFConnect (\sphinxurl{https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Connect-for-desktop})

Start NRFConnect and create a CTS server : Tap the hamburger button on the top left and select “Configure GATT server” Tap “Add service” on the bottom Select server configuration “Current Time Service” and tap OK Go back to the main screen and scan for BLE devices. A device called “PineTime” should appear Tap the button “Connect” next to the PineTime device. It should connect to the PineTime and switch to a new tab. On this tab, on the top right, there is a 3 dots button. Tap on it and select Bond. The bonding process begins, and if it is sucessful, the PineTime should update its time and display it on the screen.


\chapter{Drivers}
\label{\detokenize{drivers/drivers:drivers}}\label{\detokenize{drivers/drivers:id1}}\label{\detokenize{drivers/drivers::doc}}

\section{configuring I2C}
\label{\detokenize{drivers/i2c:configuring-i2c}}\label{\detokenize{drivers/i2c::doc}}

\subsection{board level definitions}
\label{\detokenize{drivers/i2c:board-level-definitions}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{under} \PYG{n}{boards}\PYG{o}{/}\PYG{n}{arm}\PYG{o}{/}\PYG{n}{pinetime} \PYG{n}{are} \PYG{n}{the} \PYG{n}{board} \PYG{n}{definitions}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime}\PYG{o}{.}\PYG{n}{dts}
\PYG{o}{\PYGZhy{}} \PYG{n}{pinetime\PYGZus{}defconfig}


\PYG{n}{The} \PYG{n}{sensors} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{pinetime} \PYG{n}{use} \PYG{n}{the} \PYG{n}{I2C} \PYG{n}{bus}\PYG{o}{.}

\PYG{o}{\PYGZam{}}\PYG{n}{i2c1} \PYG{p}{\PYGZob{}}
        \PYG{n}{compatible} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nordic,nrf\PYGZhy{}twi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{status} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{okay}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{sda}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
        \PYG{n}{scl}\PYG{o}{\PYGZhy{}}\PYG{n}{pin} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{7}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

      \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{definition on project level}
\label{\detokenize{drivers/i2c:definition-on-project-level}}
In the directory of a sample, you will find a prj.conf file.
Here you can set values specific for you project/sample.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prj.conf}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{file} \PYG{n}{we} \PYG{n}{define} \PYG{n}{the} \PYG{n}{sensor} \PYG{p}{(}\PYG{n}{eg} \PYG{n}{adxl372}\PYG{p}{)}

\PYG{n}{CONFIG\PYGZus{}STDOUT\PYGZus{}CONSOLE}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}LOG}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}ADXL372\PYGZus{}I2C}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{CONFIG\PYGZus{}SENSOR\PYGZus{}LOG\PYGZus{}LEVEL\PYGZus{}WRN}\PYG{o}{=}\PYG{n}{y}
\end{sphinxVerbatim}

\sphinxstylestrong{note: this gets somehow merged (overlayed) with the board definition pinetime\_defconfig}


\section{sensors on the I2C bus}
\label{\detokenize{drivers/sensors:sensors-on-the-i2c-bus}}\label{\detokenize{drivers/sensors::doc}}
0x18: Accelerometer: BMA423\sphinxhyphen{}DS000
\sphinxurl{https://github.com/BoschSensortec/BMA423-Sensor-API}

0x44: Heart Rate Sensor: HRS3300\_Heart

0x15: Touch Controller: Hynitron CST816S Touch Controller


\section{Bosch BMA421}
\label{\detokenize{drivers/bma421:bosch-bma421}}\label{\detokenize{drivers/bma421::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/gui/lvaccel}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/bma421:overview}}
BMA421 is not a part number available to the general public, and therefore all the supporting documentation and design resources are neither discussed in public forums, nor disclosed on GitHub.

CHIP\_ID=0X11  (so the Bosch BMA423 drivers need to be adapted)

The Bosch documentation on the bma423 seems to apply to the bma421.


\subsection{Requirements}
\label{\detokenize{drivers/bma421:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/bma421:adapt-cmakelists-txt}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_BMA280            bma280)
add\_subdirectory\_ifdef(CONFIG\_BMA421            bma421)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/bma421:adapt-kconfig}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/bma421:add-yaml-file}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/dts/bindings/sensor
cp bosch,bma280\sphinxhyphen{}i2c.yaml  bosch,bma421\sphinxhyphen{}i2c.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/bma421:edit-kconfig}}\begin{description}
\item[{source “drivers/sensor/bma280/Kconfig”}] \leavevmode
source “drivers/sensor/bma421/Kconfig”

\end{description}

source “drivers/sensor/bmc150\_magn/Kconfig”

source “drivers/sensor/bme280/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/bma421:create-driver}}
see under drivers/sensor/bma421

complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        bma421@18 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}bosch,bma421\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x18\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}BMA421\PYGZdq{};}
\PYG{g+go}{                   int1\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 8 0\PYGZgt{};}
\PYG{g+go}{                  \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/bosch,bma421\sphinxhyphen{}i2c.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bosch,bma421}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{include}\PYG{p}{:} \PYG{n}{i2c}\PYG{o}{\PYGZhy{}}\PYG{n}{device}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{properties}\PYG{p}{:}
       \PYG{n}{int1}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios}\PYG{p}{:}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{phandle}\PYG{o}{\PYGZhy{}}\PYG{n}{array}
       \PYG{n}{required}\PYG{p}{:} \PYG{n}{false}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/bma421:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/bma421:todo}}\begin{itemize}
\item {} 
the driver is interrupt driven as well \textendash{} need to test software

\item {} 
the sensor has algorithm for steps \textendash{} read out register

\item {} 
temperature some attempt has been made, but … (OK, temp can be read)

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/bma421:references}}
Bosch has documented the BMA423 very well.
I kind of hope it will apply to the bma421.

A mechanism to adapt the 0x5E register is provided.
(burst read/write)

All kind of parameters can be set to trigger an interrupt.
(e.g. number of steps taken : think of the 10000 steps threshold)


\section{HYNITRON CST816S}
\label{\detokenize{drivers/cst816s:hynitron-cst816s}}\label{\detokenize{drivers/cst816s::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

there is a sample in this repository which can be copied to the zephyr samples directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/cst816s}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/cst816s:overview}}
the Hynitron cst816s is a touchscreen.
In zephyr doesn’t handle touchscreens yet.
In order to investigate, the touchscreen driver has been created as a sensor.
In fact it senses your finger ;)


\subsection{Requirements}
\label{\detokenize{drivers/cst816s:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr

adapt CMakeLists.txt
adapt Kconfig
add yaml file


\subsubsection{create driver}
\label{\detokenize{drivers/cst816s:create-driver}}
The driver reads only one position.
Multitouch is possible, but the screen is small….

see under drivers/sensor/cst816s

have a look at the pinetime.dts (under board/arm/pinetime) file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        cst816s@15 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hynitron,cst816s\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x15\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}CST816S\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/cst816s:building-and-running}}\begin{description}
\item[{There are two samples :}] \leavevmode\begin{itemize}
\item {} 
samples/gui/lvtouch (graphical)

\item {} 
samples/sensor/cst816s (no graphics)

\end{itemize}

\end{description}


\subsection{Todo}
\label{\detokenize{drivers/cst816s:todo}}
The graphical sample doesn’t handle interrupts.


\subsection{References}
\label{\detokenize{drivers/cst816s:references}}
There is little available for this touchscreen.


\section{HX HRS3300}
\label{\detokenize{drivers/hrs3300:hx-hrs3300}}\label{\detokenize{drivers/hrs3300::doc}}
this driver does not exist, so it has been created.
Still work in progress ….

there is a sample in this repository which can be copied to the zephyr samples directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/hrs3300}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/hrs3300:overview}}
The HX HRS3300 sensor is a heart rate sensor, it produces 2 values: ALS and HRS. Ambient LIGHT SENSOR and HEART RATE SENSOR. Which have to be processed by an algorithm. I have no knowledge of a good open source algorithm yet.

I have used the settings of an arduino port of this library.

\noindent\sphinxincludegraphics{{hrs3300}.jpg}


\subsection{Requirements}
\label{\detokenize{drivers/hrs3300:requirements}}
for this sensor does not exist any driver, so here’s what I did to create one under zephyr


\subsubsection{adapt CMakeLists.txt}
\label{\detokenize{drivers/hrs3300:adapt-cmakelists-txt}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor
add\_subdirectory\_ifdef(CONFIG\_HRS3300           hrs3300)


\subsubsection{adapt Kconfig}
\label{\detokenize{drivers/hrs3300:adapt-kconfig}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/drivers/sensor


\subsubsection{add yaml file}
\label{\detokenize{drivers/hrs3300:add-yaml-file}}
\textasciitilde{}/zephyrproject\sphinxhyphen{}2/zephyr/dts/bindings/sensor
add  hx,hrs3300.yaml


\subsubsection{edit KConfig}
\label{\detokenize{drivers/hrs3300:edit-kconfig}}
source “drivers/sensor/hrs3300/Kconfig”


\subsubsection{create driver}
\label{\detokenize{drivers/hrs3300:create-driver}}
see under drivers/sensor/hrs3300

complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        hrs3300@44 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}hx,hrs3300\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x44\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}HRS3300\PYGZdq{};}
\PYG{g+go}{                   \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/hx,hrs3300.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hx,hrs3300}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{properties}\PYG{p}{:}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/hrs3300:building-and-running}}

\subsection{Todo}
\label{\detokenize{drivers/hrs3300:todo}}\begin{itemize}
\item {} 
algorithm for heartrate

\item {} 
power saving

\item {} 
switching off/on mechanism

\end{itemize}


\subsection{References}
\label{\detokenize{drivers/hrs3300:references}}
HRS3300 Heart Rate Sensor.pdf
\sphinxurl{https://github.com/atc1441/HRS3300-Arduino-Library}


\section{Serial Nor Flash}
\label{\detokenize{drivers/spinor:serial-nor-flash}}\label{\detokenize{drivers/spinor::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash \PYGZhy{}DCONF=prj.conf}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/spinor:overview}}
This sample application should unlock the serial nor flash memory.
This can be very usefull to store e.g. background for the watch.

compilation problematic ….

/root/zephyrproject/zephyr/samples/drivers/spi\_flash/src/main.c:17:22: error: ‘DT\_INST\_0\_JEDEC\_SPI\_NOR\_LABEL’ undeclared (first use in this function); did you mean ‘DT\_INST\_0\_NORDIC\_NRF\_RTC\_LABEL’?

Turns out this is some problem with the board definition file.

I found it to be very useful to consult the generated dts file.
Here you can check if everything is present.

Guess the dts\sphinxhyphen{}file has to be well intended.(structured)

{\color{red}\bfseries{}**}TIP: consult the generated dts board file **


\subsubsection{consulting the generated board definition file}
\label{\detokenize{drivers/spinor:consulting-the-generated-board-definition-file}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{vi /root/zephyrproject/zephyr/build/zephyr/include/generated/generated\PYGZus{}dts\PYGZus{}board.conf}
\end{sphinxVerbatim}


\subsection{Requirements}
\label{\detokenize{drivers/spinor:requirements}}
complement the pinetime.dts file with the following (under spi)
\#define JEDEC\_ID\_MACRONIX\_MX25L64      0xC22017

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}spi0 \PYGZob{}}
\PYG{g+go}{  compatible = \PYGZdq{}nordic,nrf\PYGZhy{}spi\PYGZdq{};}
\PYG{g+go}{  status = \PYGZdq{}okay\PYGZdq{};}
\PYG{g+go}{  sck\PYGZhy{}pin = \PYGZlt{}2\PYGZgt{};}
\PYG{g+go}{  mosi\PYGZhy{}pin = \PYGZlt{}3\PYGZgt{};}
\PYG{g+go}{  miso\PYGZhy{}pin = \PYGZlt{}4\PYGZgt{};}
\PYG{g+go}{  cs\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 27 0\PYGZgt{},\PYGZlt{}\PYGZam{}gpio0 5 0\PYGZgt{};}
\PYG{g+go}{  st7789v@0 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}sitronix,st7789v\PYGZdq{};}
\PYG{g+go}{          label = \PYGZdq{}DISPLAY\PYGZdq{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}8000000\PYGZgt{};}
\PYG{g+go}{          reg = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          cmd\PYGZhy{}data\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 18 0\PYGZgt{};}
\PYG{g+go}{          reset\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 26 0\PYGZgt{};}
\PYG{g+go}{          width = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          height = \PYGZlt{}240\PYGZgt{};}
\PYG{g+go}{          x\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          y\PYGZhy{}offset = \PYGZlt{}0\PYGZgt{};}
\PYG{g+go}{          vcom = \PYGZlt{}0x19\PYGZgt{};}
\PYG{g+go}{          gctrl = \PYGZlt{}0x35\PYGZgt{};}
\PYG{g+go}{          vrhs = \PYGZlt{}0x12\PYGZgt{};}
\PYG{g+go}{          vdvs = \PYGZlt{}0x20\PYGZgt{};}
\PYG{g+go}{          mdac = \PYGZlt{}0x00\PYGZgt{};}
\PYG{g+go}{          gamma = \PYGZlt{}0x01\PYGZgt{};}
\PYG{g+go}{          colmod = \PYGZlt{}0x05\PYGZgt{};}
\PYG{g+go}{          lcm = \PYGZlt{}0x2c\PYGZgt{};}
\PYG{g+go}{          porch\PYGZhy{}param = [0c 0c 00 33 33];}
\PYG{g+go}{          cmd2en\PYGZhy{}param = [5a 69 02 01];}
\PYG{g+go}{          pwctrl1\PYGZhy{}param = [a4 a1];}
\PYG{g+go}{          pvgam\PYGZhy{}param = [D0 04 0D 11 13 2B 3F 54 4C 18 0D 0B 1F 23];}
\PYG{g+go}{          nvgam\PYGZhy{}param = [D0 04 0C 11 13 2C 3F 44 51 2F 1F 1F 20 23];}
\PYG{g+go}{          ram\PYGZhy{}param = [00 F0];}
\PYG{g+go}{          rgb\PYGZhy{}param = [CD 08 14];}

\PYG{g+go}{  \PYGZcb{};}

\PYG{g+go}{  mx25r64: mx25r6435f@1 \PYGZob{}}
\PYG{g+go}{          compatible = \PYGZdq{}jedec,spi\PYGZhy{}nor\PYGZdq{};}
\PYG{g+go}{          reg = \PYGZlt{}1\PYGZgt{};}
\PYG{g+go}{          spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}1000000\PYGZgt{};}
\PYG{g+go}{          label = \PYGZdq{}MX25R64\PYGZdq{};}
\PYG{g+go}{          jedec\PYGZhy{}id = [0b 40 16];}
\PYG{g+go}{          size = \PYGZlt{}67108864\PYGZgt{};}
\PYG{g+go}{          has\PYGZhy{}be32k;}
\PYG{g+go}{  \PYGZcb{};}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{drivers/spinor:building-and-running}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/spi\PYGZus{}flash}
\end{sphinxVerbatim}


\subsection{Todo}
\label{\detokenize{drivers/spinor:todo}}\begin{quote}
\begin{itemize}
\item {} 
detect ID memory  : it is not the macronix one as suggestion on the pinetime website

\end{itemize}

I found the following : jedec\sphinxhyphen{}id = {[}0b 40 16{]}; (OK: can execute sample program)
\begin{itemize}
\item {} 
create working board definition (OK: see above)

\end{itemize}
\end{quote}


\subsection{References}
\label{\detokenize{drivers/spinor:references}}
\sphinxurl{http://files.pine64.org/doc/datasheet/pinetime/MX25L6433F,\%203V,\%2064Mb,\%20v1.6.pdf}


\section{Battery}
\label{\detokenize{drivers/battery:battery}}\label{\detokenize{drivers/battery::doc}}
the samples just gets an analog reading from the battery

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/sensor/battery}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/battery:overview}}
The battery level is measured on port 31, trough an ADC conversion.

voltage = (value * 6)/1024
percentage remaining  ((voltage \sphinxhyphen{} 3.55)*100)*3.9;

A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
Battery voltage can be in range from 3.0V \sphinxhyphen{} 4.2V (?). Unfortunately, internal reference (0.6V) can only be used for voltages up to 3.6V (due to minimal gain of 1/6). VDD/4 reference can be used with 1/6 gain to measure voltages up to 4.95V. Test is needed to check how accurate is VDD as reference.
Discharge curve (\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}) will be used to calculate charge level in percent.
Things to consider:
saadc periodical calibration (spec suggests calibration if temperature changes by 10’C)
inaccuracy of results: oversampling? never report higher level than before (if charge not connected), etc.


\subsection{Todo}
\label{\detokenize{drivers/battery:todo}}
check pin when charging


\subsection{References}
\label{\detokenize{drivers/battery:references}}
\sphinxurl{https://forum.pine64.org/showthread.php?tid=8147}


\section{Watchdog}
\label{\detokenize{drivers/watchdog:watchdog}}\label{\detokenize{drivers/watchdog::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/watchdog}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{drivers/watchdog:overview}}
Once the pinetime is closed and on your wrist, you still want access.

see : {\hyperref[\detokenize{fota/fota:fota}]{\sphinxcrossref{\DUrole{std,std-ref}{Firmware Over The Air (FOTA)}}}}

Suppose you upload a application which contains a bug, the watch freezes, and … you will have to open it up, connect the SWD …

Here comes the watchdog:
\begin{itemize}
\item {} 
you launch the watchdog

\item {} 
you launch the application

\item {} 
the application feeds the watchdog

\item {} 
if it cannot feed the watchdog, reset to fota, and you can upload another better version …

\end{itemize}


\subsection{Todo}
\label{\detokenize{drivers/watchdog:todo}}
testing


\subsection{References}
\label{\detokenize{drivers/watchdog:references}}

\chapter{Firmware Over The Air (FOTA)}
\label{\detokenize{fota/fota:firmware-over-the-air-fota}}\label{\detokenize{fota/fota:fota}}\label{\detokenize{fota/fota::doc}}

\section{Wireless Device Firmware Upgrade}
\label{\detokenize{fota/mcuboot:wireless-device-firmware-upgrade}}\label{\detokenize{fota/mcuboot:mcuboot}}\label{\detokenize{fota/mcuboot::doc}}

\subsection{Overview}
\label{\detokenize{fota/mcuboot:overview}}
In order to perform a FOTA (firmware over the air) update on zephyr you need 2 basic components:
\begin{itemize}
\item {} 
MCUboot   (a bootloader)

\item {} 
SMP Server (a bluetooth service)

\end{itemize}


\section{MCUboot with zephyr}
\label{\detokenize{fota/mcuboot:mcuboot-with-zephyr}}\label{\detokenize{fota/mcuboot:id1}}
Clone MCUBOOT for zephyr from github.
Install additional packages required for development with mcuboot:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{n}{mcuboot}  \PYG{c+c1}{\PYGZsh{} or to your directory where mcuboot is cloned}
\PYG{n}{pip3} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{scripts}\PYG{o}{/}\PYG{n}{requirements}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

To build MCUboot, create a build directory in boot/zephyr, and build
it as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{boot}\PYG{o}{/}\PYG{n}{zephyr}
\PYG{n}{mkdir} \PYG{n}{build} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{GNinja} \PYG{o}{\PYGZhy{}}\PYG{n}{DBOARD}\PYG{o}{=}\PYG{n}{pinetime} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{ninja}
\end{sphinxVerbatim}

After building the bootloader, the binaries should reside in
\sphinxtitleref{build/zephyr/zephyr.\{bin,hex,elf\}}.

This image can be flashed as a normal application.

Some additional configuration is required to build applications for MCUboot.

This is handled internally by the Zephyr configuration system and is wrapped
in the \sphinxtitleref{CONFIG\_BOOTLOADER\_MCUBOOT} Kconfig variable, which must be enabled in
the application’s \sphinxtitleref{prj.conf} file.

The Zephyr \sphinxtitleref{CONFIG\_BOOTLOADER\_MCUBOOT} configuration option
{[}documentation{]}(\sphinxurl{http://docs.zephyrproject.org/reference/kconfig/CONFIG\_BOOTLOADER\_MCUBOOT.html})
provides additional details regarding the changes it makes to the image
placement and generation in order for an application to be bootable by
MCUboot.

In order to upgrade to an image (or even boot it, if
\sphinxtitleref{MCUBOOT\_VALIDATE\_PRIMARY\_SLOT} is enabled), the images must be signed.

To make development easier, MCUboot is distributed with some example
keys.  It is important to stress that these should never be used for
production, since the private key is publicly available in this
repository.  See below on how to make your own signatures.

Images can be signed with the \sphinxtitleref{scripts/imgtool.py} script.  It is best
to look at \sphinxtitleref{samples/zephyr/Makefile} for examples on how to use this.

Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.

Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)

These images can also be marked for upgrade, and loaded into the secondary slot,
at which point the bootloader should perform an upgrade.


\section{Partitions}
\label{\detokenize{fota/partitions:partitions}}\label{\detokenize{fota/partitions:signing}}\label{\detokenize{fota/partitions::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{have a look at boards/arm/pinetime/pinetime.dts}
\end{sphinxVerbatim}


\subsection{Defining partitions for MCUboot}
\label{\detokenize{fota/partitions:defining-partitions-for-mcuboot}}
The first step required for Zephyr is making sure your board has flash
partitions defined in its device tree. These partitions are:
\begin{itemize}
\item {} 
\sphinxtitleref{boot\_partition}: for MCUboot itself

\item {} 
\sphinxtitleref{image\_0\_primary\_partition}: the primary slot of Image 0

\item {} 
\sphinxtitleref{image\_0\_secondary\_partition}: the secondary slot of Image 0

\item {} 
\sphinxtitleref{scratch\_partition}: the scratch slot

\end{itemize}

The flash partitions are defined in the pinetime boards folder, in a
file named \sphinxtitleref{boards/arm/pinetime/pinetime.dts}.


\subsection{Using NOR flash in partitions}
\label{\detokenize{fota/partitions:using-nor-flash-in-partitions}}
The flash space on the Nordic nrf52 is 512K.
Basically with the partitioning you end up with less space for your program.

As the pinetime has an extra spi nor flash chip, we can use this.

The flash\sphinxhyphen{}layout can be modified so as 1 chunk is on system flash and 1 chunk is on SPI NOR flash.
This way the space for your firmware remains almost the same.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{chosen \PYGZob{}}
\PYG{g+go}{        zephyr,flash = \PYGZam{}flash0;}
\PYG{g+go}{        //zephyr,flash = \PYGZam{}flash1;}
\PYG{g+go}{        zephyr,code\PYGZhy{}partition = \PYGZam{}slot0\PYGZus{}partition;}
\PYG{g+go}{\PYGZcb{};}


\PYG{g+go}{Rename the SPI JEDEC NOR Flash definition to : flash1}

\PYG{g+go}{flash1: mx25r6435f@1 \PYGZob{}}
\PYG{g+go}{        compatible = \PYGZdq{}jedec,spi\PYGZhy{}nor\PYGZdq{};}
\PYG{g+go}{        reg = \PYGZlt{}1\PYGZgt{};}
\PYG{g+go}{        spi\PYGZhy{}max\PYGZhy{}frequency = \PYGZlt{}80000000\PYGZgt{};}
\PYG{g+go}{        label = \PYGZdq{}MX25R64\PYGZdq{};}
\PYG{g+go}{        jedec\PYGZhy{}id = [0b 40 16];}
\PYG{g+go}{        size = \PYGZlt{}67108864\PYGZgt{};}
\PYG{g+go}{        has\PYGZhy{}be32k;}
\PYG{g+go}{        erase\PYGZhy{}block\PYGZhy{}size = \PYGZlt{}4096\PYGZgt{};}
\PYG{g+go}{        write\PYGZhy{}block\PYGZhy{}size = \PYGZlt{}4\PYGZgt{};}
\PYG{g+go}{\PYGZcb{};}




\PYG{g+go}{ \PYGZam{}flash0 \PYGZob{}}
\PYG{g+go}{        /*}
\PYG{g+go}{         * For more information, see:}
\PYG{g+go}{         * http://docs.zephyrproject.org/latest/guides/dts/index.html\PYGZsh{}flash\PYGZhy{}partitions}
\PYG{g+go}{         */}
\PYG{g+go}{        partitions \PYGZob{}}
\PYG{g+go}{                compatible = \PYGZdq{}fixed\PYGZhy{}partitions\PYGZdq{};}
\PYG{g+gp}{                \PYGZsh{}}address\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+gp}{                \PYGZsh{}}size\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}

\PYG{g+go}{                boot\PYGZus{}partition: partition@0 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}mcuboot\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00000000 0xc000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{                slot0\PYGZus{}partition: partition@c000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}0\PYGZdq{};}

\PYG{g+go}{                change the size of partition 0 from 0x32000 to 0x64000}

\PYG{g+go}{                        reg = \PYGZlt{}0x0000C000 0x64000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}

\PYG{g+go}{                move slot1 partition to \PYGZam{}flash1}

\PYG{g+go}{                //slot1\PYGZus{}partition: partition@3e000 \PYGZob{}}
\PYG{g+go}{                //      label = \PYGZdq{}image\PYGZhy{}1\PYGZdq{};}
\PYG{g+go}{                //      reg = \PYGZlt{}0x0003e000 0x32000\PYGZgt{};}
\PYG{g+go}{                //\PYGZcb{};}
\PYG{g+go}{                scratch\PYGZus{}partition: partition@70000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}scratch\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00070000 0xa000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{                storage\PYGZus{}partition: partition@7a000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}storage\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x0007a000 0x00006000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{        \PYGZcb{};}
\PYG{g+go}{ \PYGZcb{};}

\PYG{g+go}{ \PYGZam{}flash1 \PYGZob{}}
\PYG{g+go}{        partitions \PYGZob{}}
\PYG{g+go}{                compatible = \PYGZdq{}fixed\PYGZhy{}partitions\PYGZdq{};}
\PYG{g+gp}{                \PYGZsh{}}address\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+gp}{                \PYGZsh{}}size\PYGZhy{}cells \PYG{o}{=} \PYGZlt{}\PYG{l+m}{1}\PYGZgt{}\PYG{p}{;}
\PYG{g+go}{                slot1\PYGZus{}partition: partition@3e000 \PYGZob{}}
\PYG{g+go}{                        label = \PYGZdq{}image\PYGZhy{}1\PYGZdq{};}
\PYG{g+go}{                        reg = \PYGZlt{}0x00000000 0x64000\PYGZgt{};}
\PYG{g+go}{                \PYGZcb{};}
\PYG{g+go}{        \PYGZcb{};}
\PYG{g+go}{ \PYGZcb{};}
\end{sphinxVerbatim}


\section{Signing an application}
\label{\detokenize{fota/signing:signing-an-application}}\label{\detokenize{fota/signing:signing}}\label{\detokenize{fota/signing::doc}}
In order to improve the security, only signed images can be uploaded.

There is a public and private key.
The Bootloader is compiled with the public key.
Each time you want to upload firmware, you have to sign it with a private key.

\sphinxstylestrong{NOTE: it is important to keep the private key hidden}


\subsection{Generating a new keypair}
\label{\detokenize{fota/signing:generating-a-new-keypair}}
Generating a keypair with imgtool is a matter of running the keygen
subcommand:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ./scripts/imgtool.py keygen \PYGZhy{}k mykey.pem \PYGZhy{}t rsa\PYGZhy{}2048
\end{sphinxVerbatim}


\subsection{Extracting the public key}
\label{\detokenize{fota/signing:extracting-the-public-key}}
The generated keypair above contains both the public and the private
key.  It is necessary to extract the public key and insert it into the
bootloader.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ./scripts/imgtool.py getpub \PYGZhy{}k mykey.pem
\end{sphinxVerbatim}

This will output the public key as a C array that can be dropped
directly into the \sphinxtitleref{keys.c} file.


\subsection{Example}
\label{\detokenize{fota/signing:example}}
sign the compiled zephyr.bin firmware with the root\sphinxhyphen{}rsa\sphinxhyphen{}2048.pem, private key:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{imgtool.py sign \PYGZhy{}\PYGZhy{}key ../../root\PYGZhy{}rsa\PYGZhy{}2048.pem \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}header\PYGZhy{}size 0x200 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}align 8 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}version 1.2 \PYGZbs{}}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}slot\PYGZhy{}size 0x60000 \PYGZbs{}}
\PYG{g+go}{    ../mcuboot/samples/zephyr/build/ds\PYGZus{}d6/hello1/zephyr/zephyr.bin \PYGZbs{}}
\PYG{g+go}{    signed\PYGZhy{}hello1.bin}
\end{sphinxVerbatim}


\section{SMP Server Sample}
\label{\detokenize{fota/smp_svr:smp-server-sample}}\label{\detokenize{fota/smp_svr:smp-svr-sample}}\label{\detokenize{fota/smp_svr::doc}}

\subsection{Overview}
\label{\detokenize{fota/smp_svr:overview}}
This sample application implements a Simple Management Protocol (SMP) server.
SMP is a basic transfer encoding for use with the MCUmgr management protocol.

This sample application supports the following mcumgr transports by default:
\begin{itemize}
\item {} 
Shell

\item {} 
Bluetooth

\end{itemize}


\subsection{Requirements}
\label{\detokenize{fota/smp_svr:requirements}}
In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.

Here is a procedure to install mcumgr on a raspberry pi  (or similar)

It is written in the go\sphinxhyphen{}language. You need to adapt the path :   PATH=\$PATH:/root/go/bin.


\subsection{Building and Running}
\label{\detokenize{fota/smp_svr:building-and-running}}
The sample will let you manage the pinetime over bluetooth. (via SMP protocol)

There are slot0 and slot1 which can both contain firmware.

Suppose you switch from slot0 to slot1, you still want to be able to communicate.

So both slots need smp\_svr software!


\subsubsection{Step 1: Build smp\_svr}
\label{\detokenize{fota/smp_svr:step-1-build-smp-svr}}
\sphinxcode{\sphinxupquote{smp\_svr}} can be built for the nRF52 as follows:

\sphinxstylestrong{NOTE: to perform a firmware update over the air, you have to build a second sample}


\subsubsection{Step 2: Sign the image}
\label{\detokenize{fota/smp_svr:step-2-sign-the-image}}
Using MCUboot’s \sphinxcode{\sphinxupquote{imgtool.py}} script, sign the \sphinxcode{\sphinxupquote{zephyr.(bin|hex)}}
file you built in Step 3. In the below example, the MCUboot repo is located at
\sphinxcode{\sphinxupquote{\textasciitilde{}/src/mcuboot}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/src/mcuboot/scripts/imgtool.py sign \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}key \PYGZti{}/src/mcuboot/root\PYGZhy{}rsa\PYGZhy{}2048.pem \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}header\PYGZhy{}size 0x200 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}align 8 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}version 1.0 \PYGZbs{}}
\PYG{g+go}{     \PYGZhy{}\PYGZhy{}slot\PYGZhy{}size \PYGZlt{}image\PYGZhy{}slot\PYGZhy{}size\PYGZgt{} \PYGZbs{}}
\PYG{g+go}{     \PYGZlt{}path\PYGZhy{}to\PYGZhy{}zephyr.(bin|hex)\PYGZgt{} signed.(bin|hex)}
\end{sphinxVerbatim}

The above command creates an image file called \sphinxcode{\sphinxupquote{signed.(bin|hex)}} in the
current directory.


\subsubsection{Step 3: Flash the smp\_svr image}
\label{\detokenize{fota/smp_svr:step-3-flash-the-smp-svr-image}}
Upload the bin\sphinxhyphen{}file from Step 2 to image slot\sphinxhyphen{}0.
For the pinetime, slot\sphinxhyphen{}0 is located at address \sphinxcode{\sphinxupquote{0xc000}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{in openocd : program zephyr.bin 0xc000}
\end{sphinxVerbatim}


\subsubsection{Step 4: Run it!}
\label{\detokenize{fota/smp_svr:step-4-run-it}}
\begin{sphinxadmonition}{note}{Note:}
If you haven’t installed \sphinxcode{\sphinxupquote{mcumgr}} yet, then do so by following the
instructions in the \DUrole{xref,std,std-ref}{mcumgr\_cli} section of the Management subsystem
documentation.
\end{sphinxadmonition}

The \sphinxcode{\sphinxupquote{smp\_svr}} app is ready to run.  Just reset your board and test the app
with the \sphinxcode{\sphinxupquote{mcumgr}} command\sphinxhyphen{}line tool’s \sphinxcode{\sphinxupquote{echo}} functionality, which will
send a string to the remote target device and have it echo it back:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} echo hello}
\PYG{g+go}{hello}
\end{sphinxVerbatim}


\subsubsection{Step 5: Device Firmware Upgrade}
\label{\detokenize{fota/smp_svr:step-5-device-firmware-upgrade}}
Now that the SMP server is running on your pinetime, you are able to communicate
with it using \sphinxtitleref{mcumgr}.

You might want to test “OTA DFU”, or Over\sphinxhyphen{}The\sphinxhyphen{}Air Device Firmware Upgrade.

To do this, build a second sample (following the steps below) to verify
it is sent over the air and properly flashed into slot\sphinxhyphen{}1, and then
swapped into slot\sphinxhyphen{}0 by MCUboot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*} \PYG{n}{Build} \PYG{n}{a} \PYG{n}{second} \PYG{n}{sample}
\PYG{o}{*} \PYG{n}{Sign} \PYG{n}{the} \PYG{n}{second} \PYG{n}{sample}
\PYG{o}{*} \PYG{n}{Upload} \PYG{n}{the} \PYG{n}{image} \PYG{n}{over} \PYG{n}{BLE}
\end{sphinxVerbatim}

Now we are ready to send or upload the image over BLE to the target remote
device.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image upload signed.bin}
\end{sphinxVerbatim}

If all goes well the image will now be stored in slot\sphinxhyphen{}1, ready to be swapped
into slot\sphinxhyphen{}0 and executed.

\begin{sphinxadmonition}{note}{Note:}
At the beginning of the upload process, the target might start erasing
the image slot, taking several dozen seconds for some targets.  This might
cause an NMP timeout in the management protocol tool. Use the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}t \textless{}timeout\sphinxhyphen{}in\sphinxhyphen{}seconds}} option to increase the response timeout for the
\sphinxcode{\sphinxupquote{mcumgr}} command line tool if this occurs.
\end{sphinxadmonition}


\paragraph{List the images}
\label{\detokenize{fota/smp_svr:list-the-images}}
We can now obtain a list of images (slot\sphinxhyphen{}0 and slot\sphinxhyphen{}1) present in the remote
target device by issuing the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image list}
\end{sphinxVerbatim}

This should print the status and hash values of each of the images present.


\paragraph{Test the image}
\label{\detokenize{fota/smp_svr:test-the-image}}
In order to instruct MCUboot to swap the images we need to test the image first,
making sure it boots:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image test \PYGZlt{}hash of slot\PYGZhy{}1 image\PYGZgt{}}
\end{sphinxVerbatim}

Now MCUBoot will swap the image on the next reset.


\paragraph{Reset remotely}
\label{\detokenize{fota/smp_svr:reset-remotely}}
We can reset the device remotely to observe (use the console output) how
MCUboot swaps the images:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} reset}
\end{sphinxVerbatim}

Upon reset MCUboot will swap slot\sphinxhyphen{}0 and slot\sphinxhyphen{}1.

You can confirm the new image and make the swap permanent by using this command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo mcumgr \PYGZhy{}\PYGZhy{}conntype ble \PYGZhy{}\PYGZhy{}connstring ctlr\PYGZus{}name=hci0,peer\PYGZus{}name=\PYGZsq{}Zephyr\PYGZsq{} image confirm}
\end{sphinxVerbatim}

\sphinxstylestrong{Note} that if you try to send the very same image that is already flashed in
slot\sphinxhyphen{}0 then the procedure will not complete successfully since the hash values
for both slots will be identical.


\chapter{Samples and Demos}
\label{\detokenize{samples/index:samples-and-demos}}\label{\detokenize{samples/index:id1}}\label{\detokenize{samples/index::doc}}
In each sample directory is a Readme file.
This is just a collection of them.


\section{Basic Samples}
\label{\detokenize{samples/basic/basic:basic-samples}}\label{\detokenize{samples/basic/basic:basic-sample}}\label{\detokenize{samples/basic/basic::doc}}

\subsection{Blinky Application}
\label{\detokenize{samples/basic/blinky/README:blinky-application}}\label{\detokenize{samples/basic/blinky/README:blinky-sample}}\label{\detokenize{samples/basic/blinky/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/blinky/README:overview}}
The Blinky example shows how to configure GPIO pins as outputs which can also be
used to drive LEDs on the hardware usually delivered as “User LEDs” on many of
the supported boards in Zephyr.


\subsubsection{Requirements}
\label{\detokenize{samples/basic/blinky/README:requirements}}
The demo assumes that an LED is connected to one of GPIO lines. The
sample code is configured to work on boards that have defined the led0
alias in their board devicetree description file. Doing so will generate
these variables:
\begin{itemize}
\item {} 
DT\_ALIAS\_LED0\_GPIOS\_CONTROLLER

\item {} 
DT\_ALIAS\_LED0\_GPIOS\_PIN

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/blinky/README:building-and-running}}
This samples does not output anything to the console.  It can be built and
flashed to a board as follows:

After flashing the image to the board, the user LED on the board should start to
blink.


\subsection{Button demo}
\label{\detokenize{samples/basic/button/README:button-demo}}\label{\detokenize{samples/basic/button/README:button-sample}}\label{\detokenize{samples/basic/button/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/button/README:overview}}
A simple button demo showcasing the use of GPIO input with interrupts.
If the button is pressed, it will set a value at the location 0x2000F000 in memory.
With openocd or any other debugger you can peek at this location.


\subsubsection{Requirements}
\label{\detokenize{samples/basic/button/README:requirements}}
The demo assumes that a push button is connected to one of GPIO lines. The
sample code is configured to work on boards with user defined buttons and that
have defined the SW0\_* variables.

To use this sample, you will require a board that defines the user switch in its
header file. The \sphinxcode{\sphinxupquote{board.h}} must define the following variables:
\begin{itemize}
\item {} 
SW0\_GPIO\_NAME (or DT\_ALIAS\_SW0\_GPIOS\_CONTROLLER)

\item {} 
DT\_ALIAS\_SW0\_GPIOS\_PIN

\end{itemize}

Alternatively, this could also be done by defining ‘sw0’ alias in the board
devicetree description file.


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/button/README:building-and-running}}
This sample can be built for multiple boards, in this example we will build it
for the pinetime

After startup, the program looks up a predefined GPIO device, and configures the
pin in input mode, enabling interrupt generation on falling edge. During each
iteration of the main loop, the state of GPIO line is monitored and printed to
the serial console. When the input button gets pressed, the interrupt handler
will print an information about this event along with its timestamp.


\subsection{I2C Scanner sample}
\label{\detokenize{samples/basic/scani2c/README:i2c-scanner-sample}}\label{\detokenize{samples/basic/scani2c/README:i2c-scanner}}\label{\detokenize{samples/basic/scani2c/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/scani2c/README:overview}}
This sample sends I2C messages without any data (i.e. stop condition
after sending just the address). If there is an ACK for the
address, it prints the address as \sphinxcode{\sphinxupquote{FOUND}}.

\begin{sphinxadmonition}{warning}{Warning:}
As  there  is  no  standard I2C detection command, this sample
uses arbitrary SMBus commands (namely SMBus quick write and SMBus
receive byte) to probe for devices.  This sample program can confuse
your I2C bus, cause data loss, and is known to corrupt
the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
See also the \sphinxhref{http://manpages.ubuntu.com/manpages/bionic/man8/i2cdetect.8.html}{i2cdetect man page}
\end{sphinxadmonition}


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/scani2c/README:building-and-running}}

\subsection{Touchscreen IRQ}
\label{\detokenize{samples/basic/testirq/README:touchscreen-irq}}\label{\detokenize{samples/basic/testirq/README:testirq}}\label{\detokenize{samples/basic/testirq/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/testirq/README:overview}}
The touchscreen generates an interrupt when touched.


\subsubsection{Requirements}
\label{\detokenize{samples/basic/testirq/README:requirements}}
A counter that keeps track of the number of times touched.

This value is stored at a fixed location in memory, because I have a simple test setup.


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/testirq/README:building-and-running}}

\subsection{Touchpoints}
\label{\detokenize{samples/basic/touchpoints/README:touchpoints}}\label{\detokenize{samples/basic/touchpoints/README:id1}}\label{\detokenize{samples/basic/touchpoints/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/basic/touchpoints/README:overview}}
When touched the touchscreen triggers an interrupt,
it’s address 0x15 becomes visable.


\subsubsection{Requirements}
\label{\detokenize{samples/basic/touchpoints/README:requirements}}
Cach the interrupts and act upon it.

Only the first touchpoint is usable.

But a sequence of 64 has to be read.


\subsubsection{Building and Running}
\label{\detokenize{samples/basic/touchpoints/README:building-and-running}}
the purpose is just testing howto read the touchpoints of the touchscreen


\section{Sensor Samples}
\label{\detokenize{samples/sensor/sensor:sensor-samples}}\label{\detokenize{samples/sensor/sensor:id1}}\label{\detokenize{samples/sensor/sensor::doc}}

\subsection{BMA280: Three Axis High\sphinxhyphen{}g I2C/SPI Accelerometer}
\label{\detokenize{samples/sensor/bma280/README:bma280-three-axis-high-g-i2c-spi-accelerometer}}\label{\detokenize{samples/sensor/bma280/README:bma280}}\label{\detokenize{samples/sensor/bma280/README::doc}}

\subsubsection{Description}
\label{\detokenize{samples/sensor/bma280/README:description}}
This sample application produces slightly different outputs based on the chosen
driver configuration mode:
\begin{itemize}
\item {} 
In \sphinxstylestrong{Measuring Mode with trigger support},
the acceleration on all three axis is printed in m/s\textasciicircum{}2 at the sampling rate (ODR).

\item {} 
In \sphinxstylestrong{Polled Measuring Mode}, the instantaneous acceleration is polled every 2 seconds.

\item {} 
In \sphinxstylestrong{Max Peak Detect Mode}, the device returns only the over\sphinxhyphen{}threshold
peak acceleration between two consecutive sample fetches or trigger events.
(In most high\sphinxhyphen{}g applications, a single 3\sphinxhyphen{}axis acceleration sample at the peak
of an impact event contains sufficient information about the event, and the
full acceleration history is not required.) Instead of printing the acceleration
on all three axis, the sample application calculates the vector magnitude
(root sum squared) and displays the result in g’s rather than in m/s\textasciicircum{}2,
together with an bar graph.

\end{itemize}


\subsubsection{References}
\label{\detokenize{samples/sensor/bma280/README:references}}\begin{itemize}
\item {} 
BMA280: \sphinxurl{http://www.analog.com/bma280}

\end{itemize}


\subsubsection{Wiring}
\label{\detokenize{samples/sensor/bma280/README:wiring}}
This sample uses the BMA280 sensor controlled either using the I2C or SPI interface.
Connect supply \sphinxstylestrong{VDD}, \sphinxstylestrong{VS} and \sphinxstylestrong{GND}. The supply voltage can be in
the 1.6V to 3.5V range.


\paragraph{I2C mode}
\label{\detokenize{samples/sensor/bma280/README:i2c-mode}}
Connect Interface: \sphinxstylestrong{SDA}, \sphinxstylestrong{SCL} and optionally connect the \sphinxstylestrong{INT1} to a
interrupt capable GPIO. It is a requirement that \sphinxstylestrong{SCLK} must be connected to
\sphinxstylestrong{GND} in I2C mode. Depending on the baseboard used, the \sphinxstylestrong{SDA} and \sphinxstylestrong{SCL}
lines require Pull\sphinxhyphen{}Up resistors. With the \sphinxstylestrong{MISO} pin low, the I2C address for
the device is 0x1D, and an alternate I2C address of 0x53 can be chosen by
pulling the \sphinxstylestrong{MISO} pin high.

I2C Address:
\begin{itemize}
\item {} 
\sphinxstylestrong{0x1D}: if MISO is pulled low

\item {} 
\sphinxstylestrong{0x53}: if MISO is pulled high

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
When sharing an SDA bus, the BMA280 Silicon Revision \textless{} 3  may prevent
communication with other devices on that bus.
\end{sphinxadmonition}


\paragraph{SPI mode}
\label{\detokenize{samples/sensor/bma280/README:spi-mode}}
Connect Interface: \sphinxstylestrong{SCLK}, \sphinxstylestrong{MISO}, \sphinxstylestrong{MOSI} and \sphinxstylestrong{/CS} and optionally
connect the \sphinxstylestrong{INT1} to a interrupt capable GPIO.


\subsubsection{Building and Running}
\label{\detokenize{samples/sensor/bma280/README:building-and-running}}
This project outputs sensor data to the console. It requires an BMA280
sensor. It should work with any platform featuring a I2C/SPI peripheral interface.
It does not work on QEMU.


\paragraph{Sample Output: Max Peak Detect Mode}
\label{\detokenize{samples/sensor/bma280/README:sample-output-max-peak-detect-mode}}

\paragraph{Sample Output: Measurement Mode}
\label{\detokenize{samples/sensor/bma280/README:sample-output-measurement-mode}}

\subsection{CST816S HYNITRON TOUCHSCREEN}
\label{\detokenize{samples/sensor/cst816s/README:cst816s-hynitron-touchscreen}}\label{\detokenize{samples/sensor/cst816s/README:cst816s}}\label{\detokenize{samples/sensor/cst816s/README::doc}}

\subsubsection{Description}
\label{\detokenize{samples/sensor/cst816s/README:description}}
When touched the touchscreen triggers an interrupt.
This is handled in the driver.

In the sample a handler is defined.
This one gets actived by the driver.


\subsubsection{References}
\label{\detokenize{samples/sensor/cst816s/README:references}}

\subsubsection{Wiring}
\label{\detokenize{samples/sensor/cst816s/README:wiring}}

\paragraph{I2C mode}
\label{\detokenize{samples/sensor/cst816s/README:i2c-mode}}

\subsubsection{Building and Running}
\label{\detokenize{samples/sensor/cst816s/README:building-and-running}}

\paragraph{Sample Output: X \& Y coordinates}
\label{\detokenize{samples/sensor/cst816s/README:sample-output-x-y-coordinates}}

\paragraph{Sample Output: Measurement Mode}
\label{\detokenize{samples/sensor/cst816s/README:sample-output-measurement-mode}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\subsection{HRS3300 Heart Rate Sensor}
\label{\detokenize{samples/sensor/hrs3300/README:hrs3300-heart-rate-sensor}}\label{\detokenize{samples/sensor/hrs3300/README:hrs3300}}\label{\detokenize{samples/sensor/hrs3300/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/sensor/hrs3300/README:overview}}
A sensor application that demonstrates how to poll data from the hrs3300 heart
rate sensor.

It is based on the max30101 sample.


\subsubsection{Building and Running}
\label{\detokenize{samples/sensor/hrs3300/README:building-and-running}}

\paragraph{Sample Output}
\label{\detokenize{samples/sensor/hrs3300/README:sample-output}}

\section{Driver Samples}
\label{\detokenize{samples/drivers/drivers:driver-samples}}\label{\detokenize{samples/drivers/drivers:id1}}\label{\detokenize{samples/drivers/drivers::doc}}
The following samples demonstrate how to use various drivers supported
by Zephyr.


\subsection{I2C Scanner sample}
\label{\detokenize{samples/drivers/ds6_scanner/README:i2c-scanner-sample}}\label{\detokenize{samples/drivers/ds6_scanner/README:i2c-scanner}}\label{\detokenize{samples/drivers/ds6_scanner/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/drivers/ds6_scanner/README:overview}}
This sample sends I2C messages without any data (i.e. stop condition
after sending just the address). If there is an ACK for the
address, it prints the address as \sphinxcode{\sphinxupquote{FOUND}}.

\begin{sphinxadmonition}{warning}{Warning:}
As  there  is  no  standard I2C detection command, this sample
uses arbitrary SMBus commands (namely SMBus quick write and SMBus
receive byte) to probe for devices.  This sample program can confuse
your I2C bus, cause data loss, and is known to corrupt
the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
See also the \sphinxhref{http://manpages.ubuntu.com/manpages/bionic/man8/i2cdetect.8.html}{i2cdetect man page}
\end{sphinxadmonition}


\subsubsection{Building and Running}
\label{\detokenize{samples/drivers/ds6_scanner/README:building-and-running}}

\subsection{I2C Scanner sample}
\label{\detokenize{samples/drivers/i2c_scanner/README:i2c-scanner-sample}}\label{\detokenize{samples/drivers/i2c_scanner/README:i2c-scanner}}\label{\detokenize{samples/drivers/i2c_scanner/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/drivers/i2c_scanner/README:overview}}
This sample sends I2C messages without any data (i.e. stop condition
after sending just the address). If there is an ACK for the
address, it prints the address as \sphinxcode{\sphinxupquote{FOUND}}.

\begin{sphinxadmonition}{warning}{Warning:}
As  there  is  no  standard I2C detection command, this sample
uses arbitrary SMBus commands (namely SMBus quick write and SMBus
receive byte) to probe for devices.  This sample program can confuse
your I2C bus, cause data loss, and is known to corrupt
the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
See also the \sphinxhref{http://manpages.ubuntu.com/manpages/bionic/man8/i2cdetect.8.html}{i2cdetect man page}
\end{sphinxadmonition}


\subsubsection{Building and Running}
\label{\detokenize{samples/drivers/i2c_scanner/README:building-and-running}}

\section{Display Samples}
\label{\detokenize{samples/display/display:display-samples}}\label{\detokenize{samples/display/display:id1}}\label{\detokenize{samples/display/display::doc}}

\subsection{ST7789V Display driver}
\label{\detokenize{samples/display/st7789v/README:st7789v-display-driver}}\label{\detokenize{samples/display/st7789v/README:st7789v-sample}}\label{\detokenize{samples/display/st7789v/README::doc}}
make sure this patch is applied :
\sphinxurl{https://github.com/zephyrproject-rtos/zephyr/pull/20570/files}


\subsubsection{Overview}
\label{\detokenize{samples/display/st7789v/README:overview}}
This sample will draw some basic rectangles onto the display.
The rectangle colors and positions are chosen so that you can check the
orientation of the LCD and correct RGB bit order. The rectangles are drawn
in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
grey changes from black through to white. (if the grey looks too green or red
at any point then the LCD may be endian swapped).

Note: The display driver rotates the display so that the ‘natural’ LCD
orientation is effectively 270 degrees clockwise of the default display
controller orientation.


\subsubsection{Building and Running}
\label{\detokenize{samples/display/st7789v/README:building-and-running}}

\subsubsection{References}
\label{\detokenize{samples/display/st7789v/README:references}}\begin{itemize}
\item {} 
\sphinxhref{https://www.crystalfontz.com/controllers/Sitronix/ST7789V/}{ST7789V datasheet}

\end{itemize}


\section{GUI Samples}
\label{\detokenize{samples/gui/gui:gui-samples}}\label{\detokenize{samples/gui/gui:id1}}\label{\detokenize{samples/gui/gui::doc}}

\subsection{Clock Sample Current Time Service}
\label{\detokenize{samples/gui/clock-cts-rtc2/README:clock-sample-current-time-service}}\label{\detokenize{samples/gui/clock-cts-rtc2/README:clock-sample-cts}}\label{\detokenize{samples/gui/clock-cts-rtc2/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/clock-cts-rtc2/README:overview}}
This program gets the time of the bluetooth cts server and displays it.
Once it gets the time, it uses the RTC2 to generate the time.


\subsubsection{Requirements}
\label{\detokenize{samples/gui/clock-cts-rtc2/README:requirements}}
A cts server.
On linux, bluez together with a python script was used.

You need to connect to the pinetime first!
(bluetoothctl, connect \textless{}MAC\textgreater{})


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/clock-cts-rtc2/README:building-and-running}}

\subsubsection{References}
\label{\detokenize{samples/gui/clock-cts-rtc2/README:references}}

\subsection{Clock Sample Current Time Service}
\label{\detokenize{samples/gui/clock-cts/README:clock-sample-current-time-service}}\label{\detokenize{samples/gui/clock-cts/README:clock-sample-cts}}\label{\detokenize{samples/gui/clock-cts/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/clock-cts/README:overview}}
This program gets the time of the bluetooth cts server and displays it.


\subsubsection{Requirements}
\label{\detokenize{samples/gui/clock-cts/README:requirements}}
A cts server.
On linux, bluez together with a python script was used.

You need to connect to the pinetime first!
(bluetoothctl, connect \textless{}MAC\textgreater{})


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/clock-cts/README:building-and-running}}

\subsubsection{References}
\label{\detokenize{samples/gui/clock-cts/README:references}}

\subsection{LittlevGL Clock Sample}
\label{\detokenize{samples/gui/clock/README:littlevgl-clock-sample}}\label{\detokenize{samples/gui/clock/README:clock-sample}}\label{\detokenize{samples/gui/clock/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/clock/README:overview}}
This sample application displays a clock background.

This samples demonstrates the use of the counter.

Have a look at the test\_counter\_interrupt\_fn function in src/main.c


\subsubsection{Requirements}
\label{\detokenize{samples/gui/clock/README:requirements}}
You have to convert a graphical file to a “C” file, which is like a giant array.

Have a look at the prj.conf file.

It should contain CONFIG\_LVGL=y and
CONFIG\_LVGL\_OBJ\_IMAGE=y.

For the clock function it needs  CONFIG\_COUNTER=y.


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/clock/README:building-and-running}}

\subsubsection{References}
\label{\detokenize{samples/gui/clock/README:references}}

\subsection{Adafruit GFX Library on ST7789V Display}
\label{\detokenize{samples/gui/gfx/README:adafruit-gfx-library-on-st7789v-display}}\label{\detokenize{samples/gui/gfx/README:gfx-sample}}\label{\detokenize{samples/gui/gfx/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/gfx/README:overview}}
This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.


\subsection{Display accel values}
\label{\detokenize{samples/gui/lvaccel/README:display-accel-values}}\label{\detokenize{samples/gui/lvaccel/README:lvaccel-sample}}\label{\detokenize{samples/gui/lvaccel/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/lvaccel/README:overview}}
This sample application displays “Hello World” in the center of the screen
and a counter at the bottom which increments every second.

It display the values x,y,z from the bosch BMA421 accel sensor.


\subsubsection{Requirements}
\label{\detokenize{samples/gui/lvaccel/README:requirements}}
Pinetime watch
definitions can be found under the boards sub\sphinxhyphen{}directory
\begin{itemize}
\item {} 
pinetime.conf

\item {} 
pinetime.overlay

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/lvaccel/README:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b pinetime samples/gui/lvgl


\subsubsection{References}
\label{\detokenize{samples/gui/lvaccel/README:references}}

\subsection{LittlevGL Basic Sample}
\label{\detokenize{samples/gui/lvgl/README:littlevgl-basic-sample}}\label{\detokenize{samples/gui/lvgl/README:lvgl-sample}}\label{\detokenize{samples/gui/lvgl/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/lvgl/README:overview}}
This sample application displays “Hello World” in the center of the screen
and a counter at the bottom which increments every second.


\subsubsection{Requirements}
\label{\detokenize{samples/gui/lvgl/README:requirements}}
Pinetime watch
definitions can be found under the boards sub\sphinxhyphen{}directory
\begin{itemize}
\item {} 
pinetime.conf

\item {} 
pinetime.overlay

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/lvgl/README:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b pinetime samples/gui/lvgl


\subsubsection{References}
\label{\detokenize{samples/gui/lvgl/README:references}}

\subsection{Touchscreen Basic Sample}
\label{\detokenize{samples/gui/lvtouch/README:touchscreen-basic-sample}}\label{\detokenize{samples/gui/lvtouch/README:touchscreen-sample}}\label{\detokenize{samples/gui/lvtouch/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/gui/lvtouch/README:overview}}
This sample application displays touchscreen\sphinxhyphen{}values x and y in the center of the screen.

The touchscreen triggers an interrupt when touched.
This means that data is ready and can be collected.

However, using the interrupt with the handler, does not seem to work within the GUI.
When used in samples/sensor/cst816s, it runs….


\subsubsection{Requirements}
\label{\detokenize{samples/gui/lvtouch/README:requirements}}
Pinetime watch
zephyr cst816s driver


\subsubsection{Building and Running}
\label{\detokenize{samples/gui/lvtouch/README:building-and-running}}
west build \sphinxhyphen{}p \sphinxhyphen{}b pinetime samples/gui/lvtouch


\subsubsection{References}
\label{\detokenize{samples/gui/lvtouch/README:references}}

\section{Bluetooth Samples}
\label{\detokenize{samples/bluetooth/bluetooth:bluetooth-samples}}\label{\detokenize{samples/bluetooth/bluetooth:id1}}\label{\detokenize{samples/bluetooth/bluetooth::doc}}

\subsection{Bluetooth: Central / Heart\sphinxhyphen{}rate Monitor}
\label{\detokenize{samples/bluetooth/central_hr/README:bluetooth-central-heart-rate-monitor}}\label{\detokenize{samples/bluetooth/central_hr/README:bluetooth-central-hr}}\label{\detokenize{samples/bluetooth/central_hr/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/bluetooth/central_hr/README:overview}}
Similar to the \DUrole{xref,std,std-ref}{Central} sample, except that this
application specifically looks for heart\sphinxhyphen{}rate monitors and reports the
heart\sphinxhyphen{}rate readings once connected.


\subsubsection{Requirements}
\label{\detokenize{samples/bluetooth/central_hr/README:requirements}}\begin{itemize}
\item {} 
BlueZ running on the host, or

\item {} 
A board with BLE support

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/bluetooth/central_hr/README:building-and-running}}
This sample can be found under {\color{red}\bfseries{}:zephyr\_file:\textasciigrave{}samples/bluetooth/central\_hr\textasciigrave{}} in the
Zephyr tree.

See {\hyperref[\detokenize{samples/bluetooth/bluetooth:bluetooth-samples}]{\sphinxcrossref{\DUrole{std,std-ref}{bluetooth samples section}}}} for details.


\subsection{Bluetooth: Eddystone}
\label{\detokenize{samples/bluetooth/eddystone/README:bluetooth-eddystone}}\label{\detokenize{samples/bluetooth/eddystone/README:bluetooth-eddystone-sample}}\label{\detokenize{samples/bluetooth/eddystone/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/bluetooth/eddystone/README:overview}}
Application demonstrating \sphinxhref{https://github.com/google/eddystone/tree/master/configuration-service}{Eddystone Configuration Service}

The Eddystone Configuration Service runs as a GATT service on the beacon while
it is connectable and allows configuration of the advertised data, the
broadcast power levels, and the advertising intervals. It also forms part of
the definition of how Eddystone\sphinxhyphen{}EID beacons are configured and registered with
a trusted resolver.


\subsubsection{Requirements}
\label{\detokenize{samples/bluetooth/eddystone/README:requirements}}\begin{itemize}
\item {} 
BlueZ running on the host, or

\item {} 
A board with BLE support

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/bluetooth/eddystone/README:building-and-running}}
This sample can be found under {\color{red}\bfseries{}:zephyr\_file:\textasciigrave{}samples/bluetooth/eddystone\textasciigrave{}} in the
Zephyr tree.

See {\hyperref[\detokenize{samples/bluetooth/bluetooth:bluetooth-samples}]{\sphinxcrossref{\DUrole{std,std-ref}{bluetooth samples section}}}} for details.


\subsection{Bluetooth: Peripheral\_cts}
\label{\detokenize{samples/bluetooth/peripheral-cts/README:bluetooth-peripheral-cts}}\label{\detokenize{samples/bluetooth/peripheral-cts/README:ble-peripheral-cts}}\label{\detokenize{samples/bluetooth/peripheral-cts/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/bluetooth/peripheral-cts/README:overview}}
Application demonstrating reading the time from a CTS service.

I used bluez on linux + a gatt server script that presents a current time service.

This program tests if it can get the time of a cts service. In order to get the time, you will have to connect the device first.


\subsubsection{Requirements}
\label{\detokenize{samples/bluetooth/peripheral-cts/README:requirements}}\begin{itemize}
\item {} 
a bluetoothdevice running the CTS service

\item {} 
a board with this software (pinetime)

\end{itemize}

You will need a serial port to read the output of the “printk” messages.


\subsubsection{Building and Running}
\label{\detokenize{samples/bluetooth/peripheral-cts/README:building-and-running}}

\subsection{Bluetooth: Peripheral}
\label{\detokenize{samples/bluetooth/peripheral/README:bluetooth-peripheral}}\label{\detokenize{samples/bluetooth/peripheral/README:ble-peripheral}}\label{\detokenize{samples/bluetooth/peripheral/README::doc}}

\subsubsection{Overview}
\label{\detokenize{samples/bluetooth/peripheral/README:overview}}
Application demonstrating the BLE Peripheral role. It has several well\sphinxhyphen{}known and
vendor\sphinxhyphen{}specific GATT services that it exposes.


\subsubsection{Requirements}
\label{\detokenize{samples/bluetooth/peripheral/README:requirements}}\begin{itemize}
\item {} 
BlueZ running on the host, or

\item {} 
A board with BLE support

\end{itemize}


\subsubsection{Building and Running}
\label{\detokenize{samples/bluetooth/peripheral/README:building-and-running}}
This sample can be found under {\color{red}\bfseries{}:pinetime\_file:\textasciigrave{}samples/bluetooth/peripheral\textasciigrave{}} in the
Zephyr tree.

See {\hyperref[\detokenize{samples/bluetooth/bluetooth:bluetooth-samples}]{\sphinxcrossref{\DUrole{std,std-ref}{bluetooth samples section}}}} for details.


\chapter{Menuconfig}
\label{\detokenize{menuconfig:menuconfig}}\label{\detokenize{menuconfig::doc}}

\section{Zephyr is like linux}
\label{\detokenize{menuconfig:zephyr-is-like-linux}}
\sphinxstylestrong{TIP: the pinetime specific drivers are located under Modules}

\sphinxstylestrong{Note:}  to get a feel, compile a program, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/bluetooth/peripheral \PYGZhy{}D CONF\PYGZus{}FILE=\PYGZdq{}prj.conf\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{the pinetime contains an external 32Kz crystal}}
now you can have a look in the configurationfile (and modify if needed)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} west build \PYGZhy{}t menuconfig
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Modules}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{nRF52832}\PYG{o}{\PYGZhy{}}\PYG{n}{MDK}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Board} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{SoC}\PYG{o}{/}\PYG{n}{CPU}\PYG{o}{/}\PYG{n}{Configuration} \PYG{n}{Selection} \PYG{p}{(}\PYG{n}{Nordic} \PYG{n}{Semiconductor} \PYG{n}{nRF52} \PYG{n}{series} \PYG{n}{MCU}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Hardware} \PYG{n}{Configuration}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{ARM} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Architecture} \PYG{p}{(}\PYG{n}{ARM} \PYG{n}{architecture}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{General} \PYG{n}{Architecture} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Floating} \PYG{n}{point}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{General} \PYG{n}{Kernel} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Device} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
    \PYG{n}{C} \PYG{n}{Library}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Additional} \PYG{n}{libraries}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Bluetooth}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Console} \PYG{n}{subsystem}\PYG{o}{/}\PYG{n}{support} \PYG{n}{routines} \PYG{p}{[}\PYG{n}{EXPERIMENTAL}\PYG{p}{]}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{support} \PYG{k}{for} \PYG{n}{the} \PYG{n}{application}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{System} \PYG{n}{Monitoring} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Debugging} \PYG{n}{Options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Disk} \PYG{n}{Interface}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{File} \PYG{n}{Systems}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Logging}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Management}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Networking}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IEEE} \PYG{l+m+mf}{802.15}\PYG{o}{.}\PYG{l+m+mi}{4} \PYG{n}{drivers} \PYG{n}{options}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{n}{UART\PYGZus{}0}\PYG{p}{)} \PYG{n}{Device} \PYG{n}{Name} \PYG{n}{of} \PYG{n}{UART} \PYG{n}{Device} \PYG{k}{for} \PYG{n}{UART} \PYG{n}{Console}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Console} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Net} \PYG{n}{loopback} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Serial} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Interrupt} \PYG{n}{Controllers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
    \PYG{n}{Timer} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{\PYGZhy{}} \PYG{n}{Entropy} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{GPIO} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Shared} \PYG{n}{interrupt} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{SPI} \PYG{n}{hardware} \PYG{n}{bus} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2C} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{I2S} \PYG{n}{bus} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{PWM} \PYG{p}{(}\PYG{n}{Pulse} \PYG{n}{Width} \PYG{n}{Modulation}\PYG{p}{)} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Enable} \PYG{n}{board} \PYG{n}{pinmux} \PYG{n}{driver}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{ADC} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Watchdog} \PYG{n}{Support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{Hardware} \PYG{n}{clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Precision} \PYG{n}{Time} \PYG{n}{Protocol} \PYG{n}{Clock} \PYG{n}{driver} \PYG{n}{support}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{IPM} \PYG{n}{drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{ipm} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Flash} \PYG{n}{hardware} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{[} \PYG{p}{]} \PYG{n}{Sensor} \PYG{n}{Drivers}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{Max} \PYG{n}{compiled}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{log} \PYG{n}{level} \PYG{k}{for} \PYG{n}{clock} \PYG{n}{control} \PYG{p}{(}\PYG{n}{Info}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{p}{[}\PYG{o}{*}\PYG{p}{]} \PYG{n}{NRF} \PYG{n}{Clock} \PYG{n}{controller} \PYG{n}{support}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{SELECT} \PYG{n}{THIS} \PYG{n}{ONE}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{o}{\PYGZlt{}}
\end{sphinxVerbatim}


\chapter{Hacking stuff}
\label{\detokenize{hacking/hacking:hacking-stuff}}\label{\detokenize{hacking/hacking:hacking}}\label{\detokenize{hacking/hacking::doc}}

\section{hacking   the pinetime smartwatch}
\label{\detokenize{hacking/flashing:hacking-the-pinetime-smartwatch}}\label{\detokenize{hacking/flashing::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{o+ow}{is} \PYG{n}{preloaded} \PYG{k}{with} \PYG{n}{firmware}\PYG{o}{.}
\PYG{n}{This} \PYG{n}{firmware} \PYG{o+ow}{is} \PYG{n}{secured}\PYG{p}{,} \PYG{n}{you} \PYG{n}{cannot} \PYG{n}{peek} \PYG{n}{into} \PYG{n}{it}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The pinetime has a swd interface.
To be able to write firmware,  you need special hardware.
I use a stm\sphinxhyphen{}link which is very cheap(2\$).
You can also use the GPIO header of a raspberry pi.
(my repo: \sphinxurl{https://github.com/najnesnaj/openocd} is adapted for the orange pi)
\end{sphinxadmonition}

To flash the software I use openocd :
example for stm\sphinxhyphen{}link usb\sphinxhyphen{}stick

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}} openocd \PYGZhy{}s /usr/local/share/openocd/scripts \PYGZhy{}f interface/stlink.cfg \PYGZhy{}f target/nrf52.cfg
\end{sphinxVerbatim}

example for the orange\sphinxhyphen{}pi GPIO header (or raspberry)
\begin{quote}

\# openocd \sphinxhyphen{}f /usr/local/share/openocd/scripts/interface/sysfsgpio\sphinxhyphen{}raspberrypi.cfg
\sphinxhyphen{}c ‘transport select swd’ \sphinxhyphen{}f /usr/local/share/openocd/scripts/target/nrf52.cfg
\sphinxhyphen{}c ‘bindto 0.0.0.0’
\end{quote}

once you started the openocd background server, you can connect to it using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}} program zephyr.bin

\PYG{g+go}{target halted due to debug\PYGZhy{}request, current mode: Thread}
\PYG{g+go}{xPSR: 0x01000000 pc: 0x00001534 msp: 0x20004a10}
\PYG{g+go}{** Programming Started **}
\PYG{g+go}{auto erase enabled}
\PYG{g+go}{using fast async flash loader. This is currently supported}
\PYG{g+go}{only with ST\PYGZhy{}Link and CMSIS\PYGZhy{}DAP. If you have issues, add}
\PYG{g+go}{\PYGZdq{}set WORKAREASIZE 0\PYGZdq{} before sourcing nrf51.cfg/nrf52.cfg to disable it}
\PYG{g+go}{target halted due to breakpoint, current mode: Thread}
\PYG{g+go}{xPSR: 0x61000000 pc: 0x2000001e msp: 0x20004a10}
\PYG{g+go}{wrote 24576 bytes from file zephyr.bin in 1.703540s (14.088 KiB/s)}
\PYG{g+go}{** Programming Finished **}

\PYG{g+go}{And finally execute a reset :}
\PYG{g+gp}{\PYGZgt{}}reset
\end{sphinxVerbatim}

removing write protection see:   {\hyperref[\detokenize{hacking/writeprotection:flashing}]{\sphinxcrossref{\DUrole{std,std-ref}{howto flash your zephyr image}}}}


\section{debugging   the pinetime smartwatch}
\label{\detokenize{hacking/debugging:debugging-the-pinetime-smartwatch}}\label{\detokenize{hacking/debugging::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{I} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{segger} \PYG{n}{debugging} \PYG{n}{probe}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this}\PYG{p}{,} \PYG{n}{it} \PYG{n}{to} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

programming

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1

\PYG{g+go}{the last byte shows the value of your program trace value}
\end{sphinxVerbatim}


\section{scanning the I2C\_1 port}
\label{\detokenize{hacking/i2cscanning:scanning-the-i2c-1-port}}\label{\detokenize{hacking/i2cscanning:i2cscanning}}\label{\detokenize{hacking/i2cscanning::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{serial} \PYG{n}{port}\PYG{o}{.}
\PYG{n}{I} \PYG{n}{do} \PYG{o+ow}{not} \PYG{n}{have} \PYG{n}{a} \PYG{n}{segger} \PYG{n}{debugging} \PYG{n}{probe}\PYG{o}{.}
\PYG{n}{A} \PYG{n}{way} \PYG{n}{around} \PYG{n}{this}\PYG{p}{,} \PYG{n}{it} \PYG{n}{to} \PYG{n}{put} \PYG{n}{a} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{memory} \PYG{n}{at} \PYG{n}{a} \PYG{n}{fixed} \PYG{n}{location}\PYG{o}{.}
\PYG{n}{With} \PYG{n}{openocd} \PYG{n}{you} \PYG{n}{can} \PYG{n}{peek} \PYG{n}{at} \PYG{n}{this} \PYG{n}{memory} \PYG{n}{location}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{hacking/i2cscanning:building-and-running}}
In this repo under samples you will find an adapted i2c scanner program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/i2c\PYGZus{}scanner}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\#define MY\_REGISTER (*(volatile uint8\_t*)0x2000F000)

in the program you can set values:
MY\_REGISTER=1;
MY\_REGISTER=8;

this way you know till where the code executes
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}telnet \PYG{l+m}{127}.0.0.1 \PYG{l+m}{4444}
\end{sphinxVerbatim}

Peeking

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{once your telnet sessions started:}
\PYG{g+go}{Trying 127.0.0.1...}
\PYG{g+go}{Connected to 127.0.0.1.}
\PYG{g+go}{Escape character is \PYGZsq{}\PYGZca{}]\PYGZsq{}.}
\PYG{g+go}{Open On\PYGZhy{}Chip Debugger}
\PYG{g+gp}{\PYGZgt{}}mdw 0x2000F000 0x1
\PYG{g+go}{0x2000f000: 00c24418}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Note:}:

this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first….)


\section{howto flash your zephyr image}
\label{\detokenize{hacking/writeprotection:howto-flash-your-zephyr-image}}\label{\detokenize{hacking/writeprotection:flashing}}\label{\detokenize{hacking/writeprotection::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{   \PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{   here you can find zephyr.bin which you can flash}




\PYG{g+go}{I use Openocd to flash.}
\PYG{g+go}{Just connect : telnet 127.0.0.1 4444}

\PYG{g+go}{.. code\PYGZhy{}block:: console}

\PYG{g+go}{    program zephyr.bin}
\end{sphinxVerbatim}


\section{howto remove the write protection}
\label{\detokenize{hacking/writeprotection:howto-remove-the-write-protection}}\begin{description}
\item[{::}] \leavevmode
the PineTime watch is read/write protected (at least the one I got)
executing the following : nrf52.dap apreg 1 0x0c shows 0x0

Mind you, st\sphinxhyphen{}link does not allow you to execute that command, for this you will need a J\sphinxhyphen{}link.

There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won’t need an external programmer at all)
(You can find an example for the orange pi in my repo :\sphinxurl{https://github.com/najnesnaj/openocd}.)
You have to reconfigure Openocd with the \textendash{}enable\sphinxhyphen{}cmsis\sphinxhyphen{}dap option.

Unlock the chip by executing the command:
\textgreater{} nrf52.dap apreg 1 0x04 0x01

\end{description}


\section{howto configure gateway}
\label{\detokenize{hacking/infrastructure:howto-configure-gateway}}\label{\detokenize{hacking/infrastructure:infrastructure}}\label{\detokenize{hacking/infrastructure::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{here you can find zephyr.bin which you can flash}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{I} \PYG{n}{use} \PYG{n}{an} \PYG{n}{orange} \PYG{n}{pi} \PYG{n}{single} \PYG{n}{board} \PYG{n}{computer}\PYG{o}{.}
\PYG{n}{The} \PYG{n}{pinetime} \PYG{n}{watch} \PYG{o+ow}{is} \PYG{n}{attached} \PYG{n}{to} \PYG{n}{this}\PYG{o}{.}
\PYG{n}{My} \PYG{n}{development} \PYG{o+ow}{is} \PYG{n}{done} \PYG{n}{on} \PYG{n}{a} \PYG{n}{laptop}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
How can you copy from one environment (laptop) to another (SBC) without typing password?
\end{sphinxVerbatim}

On the laptop :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ssh\PYGZhy{}keygen \PYGZhy{}b 8092 \PYGZhy{}t rsa \PYGZhy{}C \PYGZdq{}fota gw access key\PYGZdq{} \PYGZhy{}f \PYGZti{}/.ssh/orange}
\PYG{g+go}{Generating public/private rsa key pair.}
\PYG{g+go}{Enter passphrase (empty for no passphrase):          (LEAVE EMPTY!)}
\PYG{g+go}{Enter same passphrase again:}
\PYG{g+go}{Your identification has been saved in /root/.ssh/orange.}
\PYG{g+go}{Your public key has been saved in /root/.ssh/orange.pub.}
\PYG{g+go}{The key fingerprint is:}
\PYG{g+go}{SHA256:xCM5Fk1LAVjEWqrM6LKM8Y6+Y12ONt6eV8vDa/KdRUM fota gw access key}
\PYG{g+go}{The key\PYGZsq{}s randomart image is:}
\PYG{g+go}{+\PYGZhy{}\PYGZhy{}\PYGZhy{}[RSA 8092]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{g+go}{|     ==++.       |}
\PYG{g+go}{|B*B.o+. +ooo     |}
\PYG{g+go}{+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}[SHA256]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}

\PYG{g+gp+gpVirtualEnv}{(the standard port is 22 and not 9988 which is my custom port)}

\PYG{g+go}{copy the certificate to the SBC (which name is orange in my case):}
\PYG{g+go}{ssh\PYGZhy{}copy\PYGZhy{}id \PYGZhy{}p 9988 \PYGZhy{}i \PYGZti{}/.ssh/orange.pub root@orange}


\PYG{g+go}{create config file :  \PYGZti{}/.ssh/config}
\PYG{g+go}{      Host orange}
\PYG{g+go}{      HostName orange}
\PYG{g+go}{      User root}
\PYG{g+go}{      Port 9988}
\PYG{g+go}{      IdentityFile \PYGZti{}/.ssh/orange}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Now} \PYG{n}{you} \PYG{n}{can} \PYG{n}{copy} \PYG{n}{without} \PYG{n}{a} \PYG{n}{password} \PYG{p}{:}
\PYG{n}{scp} \PYG{n}{build}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{/}\PYG{n}{zephyr}\PYG{o}{.}\PYG{n}{bin} \PYG{n}{orange}\PYG{p}{:}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{hacking/openocd:openocd}}
w


\section{howto use 2 openocd sessions}
\label{\detokenize{hacking/openocd:howto-use-2-openocd-sessions}}\label{\detokenize{hacking/openocd::doc}}
Once you completed your \sphinxcode{\sphinxupquote{west build}} , your image is located under the build directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{   \PYGZdl{}} \PYG{n+nb}{cd} \PYGZti{}/work/pinetime/zephyr/build/zephyr
\PYG{g+go}{   here you can find zephyr.bin which you can flash}




\PYG{g+go}{I use Openocd to flash.}
\PYG{g+go}{Just connect : telnet 127.0.0.1 4444}

\PYG{g+go}{.. code\PYGZhy{}block:: console}

\PYG{g+go}{    program zephyr.bin}
\end{sphinxVerbatim}


\subsection{Suppose you have 2 microcontrollers}
\label{\detokenize{hacking/openocd:suppose-you-have-2-microcontrollers}}\begin{quote}

Just connect : telnet 127.0.0.1 7777 for the second.
\end{quote}


\subsection{Howto setup a second openocd session on a different port?}
\label{\detokenize{hacking/openocd:howto-setup-a-second-openocd-session-on-a-different-port}}
In this case an ST\sphinxhyphen{}LINK/V2 an in\sphinxhyphen{}circuit debugger and programmer is used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openocd} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{telnet\PYGZus{}port 7777}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tcl\PYGZus{}port 6667}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gdb\PYGZus{}port 3332}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{interface}\PYG{o}{/}\PYG{n}{stlink}\PYG{o}{.}\PYG{n}{cfg}  \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{target}\PYG{o}{/}\PYG{n}{nrf52}\PYG{o}{.}\PYG{n}{cfg}
\end{sphinxVerbatim}


\subsection{Howto use the GPIO header of a Single Board computer}
\label{\detokenize{hacking/openocd:howto-use-the-gpio-header-of-a-single-board-computer}}
This works really well, and does not require a seperate programmer.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openocd} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts}\PYG{o}{/}\PYG{n}{interface}\PYG{o}{/}\PYG{n}{sysfsgpio}\PYG{o}{\PYGZhy{}}\PYG{n}{raspberrypi}\PYG{o}{.}\PYG{n}{cfg} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transport select swd}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{openocd}\PYG{o}{/}\PYG{n}{scripts}\PYG{o}{/}\PYG{n}{target}\PYG{o}{/}\PYG{n}{nrf52}\PYG{o}{.}\PYG{n}{cfg}  \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bindto 0.0.0.0}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\section{howto generate pdf documents}
\label{\detokenize{hacking/latexpdf:howto-generate-pdf-documents}}\label{\detokenize{hacking/latexpdf::doc}}
sphinx cannot generate pdf directly, and needs latex

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{latexmk}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{fonts}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{xzdec}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{cmap}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{extra}
\end{sphinxVerbatim}


\chapter{Behind the scene}
\label{\detokenize{behind/behind:behind-the-scene}}\label{\detokenize{behind/behind:id1}}\label{\detokenize{behind/behind::doc}}

\section{Behind the scene}
\label{\detokenize{behind/behind-the-scene:behind-the-scene}}\label{\detokenize{behind/behind-the-scene::doc}}

\subsection{Overview}
\label{\detokenize{behind/behind-the-scene:overview}}
I’m not a zephyr expert and am learning on the way.

In this chapter I let you glimpse behind the scene. (and notice all the struggle)

In case of the accel sensor, I used the bosch bma280 as a template.

In case of the touchscreen, I soon ran into trouble.
So I tried splitting a complex problem into simpler ones.

This allowed me to detect problems easier.

The created samples might be of some use, if you run into trouble or if you want to extend the functionality.


\section{development trajectory}
\label{\detokenize{behind/bma280:development-trajectory}}\label{\detokenize{behind/bma280::doc}}
The final goal is to use the accel\sphinxhyphen{}sensor in the watch (BMA423), which does not exist yet.
In order to minimize the effort:
\begin{itemize}
\item {} 
we’ll use something that looks like it (ADXL372), because there exists an example.

\item {} 
next we adapt it to use the existing BMA280 sensor (under drivers/sensor), so we get a sample that works with the BMA280.

\item {} 
we create a driver for the BMA423, based upon the BMA280

\item {} 
we adapt the sample for the BMA280 to BMA423

\end{itemize}


\section{Bosch BMA280}
\label{\detokenize{behind/bma280:bosch-bma280}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{west build \PYGZhy{}p \PYGZhy{}b pinetime samples/drivers/bma280}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{behind/bma280:overview}}
This sample application mimics the presence of a bosch, bma280 accel sensor.
For this sensor exists a driver in zephyr, but no sample.
Remember, I’m not a zephyr expert and am learning on the way.


\subsection{Requirements}
\label{\detokenize{behind/bma280:requirements}}
complement the pinetime.dts file with the following (under samples/sensor/bma280)

This will supplement / override what’s already definition on the board level (boards/arm/pinetime)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        bma280@18 \PYGZob{}}
\PYG{g+go}{                   compatible = \PYGZdq{}bosch,bma280\PYGZdq{};}
\PYG{g+go}{                   reg = \PYGZlt{}0x18\PYGZgt{};}
\PYG{g+go}{                   label = \PYGZdq{}BMA280\PYGZdq{};}
\PYG{g+go}{                   int1\PYGZhy{}gpios = \PYGZlt{}\PYGZam{}gpio0 8 0\PYGZgt{};}
\PYG{g+go}{                  \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/bosch,bma280\sphinxhyphen{}i2c.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bosch,bma280}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{include}\PYG{p}{:} \PYG{n}{i2c}\PYG{o}{\PYGZhy{}}\PYG{n}{device}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{properties}\PYG{p}{:}
       \PYG{n}{int1}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios}\PYG{p}{:}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{phandle}\PYG{o}{\PYGZhy{}}\PYG{n}{array}
       \PYG{n}{required}\PYG{p}{:} \PYG{n}{false}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{behind/bma280:building-and-running}}

\subsection{Todo}
\label{\detokenize{behind/bma280:todo}}\begin{itemize}
\item {} 
since no serial port and no J\sphinxhyphen{}LINK, I have to print messages to the screen (see sample gui/lvaccel)

\item {} 
I adapted the BMA driver so it accepts the CHIP\_ID, further registers are subject to investigation, since no doc

\end{itemize}


\subsection{References}
\label{\detokenize{behind/bma280:references}}
BMA421 is not a part number available to the general public, and therefore all the supporting documentation and design resources are neither discussed in public forums, nor disclosed on GitHub.

CHIP\_ID=0X11  (so 423 drivers need to be adapted)


\section{Touchscreen Hynitron}
\label{\detokenize{behind/touchscreen:touchscreen-hynitron}}\label{\detokenize{behind/touchscreen::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{git clone https://github.com/lupyuen/hynitron\PYGZus{}i2c\PYGZus{}cst0xxse}
\end{sphinxVerbatim}


\subsection{Overview}
\label{\detokenize{behind/touchscreen:overview}}
this does not exist yet in zephyr, but there is work in progress
\sphinxurl{https://github.com/zephyrproject-rtos/zephyr/pull/16119}


\subsection{Requirements}
\label{\detokenize{behind/touchscreen:requirements}}
complement the pinetime.dts file with the following (under samples/sensor/bma280)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}i2c1 \PYGZob{}}
\PYG{g+go}{        touch@18 \PYGZob{}}
\PYG{g+go}{                  \PYGZcb{};}
\PYG{g+go}{       \PYGZcb{};}
\end{sphinxVerbatim}

Create a file: \sphinxtitleref{/dts/bindings/sensor/touch.yaml}.
Which contains:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compatible}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{touch}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{include}\PYG{p}{:} \PYG{n}{i2c}\PYG{o}{\PYGZhy{}}\PYG{n}{device}\PYG{o}{.}\PYG{n}{yaml}
\PYG{n}{properties}\PYG{p}{:}
       \PYG{n}{int1}\PYG{o}{\PYGZhy{}}\PYG{n}{gpios}\PYG{p}{:}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{phandle}\PYG{o}{\PYGZhy{}}\PYG{n}{array}
       \PYG{n}{required}\PYG{p}{:} \PYG{n}{false}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{behind/touchscreen:building-and-running}}

\subsection{Todo}
\label{\detokenize{behind/touchscreen:todo}}\begin{quote}

\sphinxhyphen{}create touchscreen driver
\sphinxhyphen{}create sample
\end{quote}


\subsection{References}
\label{\detokenize{behind/touchscreen:references}}

\section{Troubleshooting drivers}
\label{\detokenize{behind/troubleshoot:troubleshooting-drivers}}\label{\detokenize{behind/troubleshoot::doc}}
Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.

Adapting existing drivers did not get me the desired quick results.

Even after analysing the behaviour, setting values at each function step, did not get me any further.


\subsection{Overview}
\label{\detokenize{behind/troubleshoot:overview}}
The drivers can use interrupts.

In the settings/config one can choose between OWN\_THREAD and GLOBAL\_THREAD.

This affect the behaviour of how threads are handled.

The tread\sphinxhyphen{}handling and interrupt\sphinxhyphen{}handling occurs in the driver itself.

An interrupt is handled immediatly, the processing is offloaded to the threading.


\subsection{Example}
\label{\detokenize{behind/troubleshoot:example}}\begin{itemize}
\item {} 
You touch the touchscreen

\item {} 
the touchscreen generates an interrupt

\item {} 
the driver handles the interrupt

\item {} 
a thread is created by the interrupt

\item {} 
the threadhandling read the I2C\sphinxhyphen{}bus

\end{itemize}


\subsection{Requirements}
\label{\detokenize{behind/troubleshoot:requirements}}
In order to create a working driver, I took it apart :

(split a complex problem into simple problems)


\subsubsection{a sample to detect interrupt}
\label{\detokenize{behind/troubleshoot:a-sample-to-detect-interrupt}}
samples/basic/testirq

Each time the touchscreen gets touched, it increases a counter.


\subsubsection{a sample to scan the I2C\sphinxhyphen{}BUS}
\label{\detokenize{behind/troubleshoot:a-sample-to-scan-the-i2c-bus}}\begin{quote}

({\hyperref[\detokenize{hacking/i2cscanning:i2cscanning}]{\sphinxcrossref{\DUrole{std,std-ref}{scanning the I2C\_1 port}}}}),
\end{quote}


\subsubsection{a sample to read the I2C\sphinxhyphen{}BUS}
\label{\detokenize{behind/troubleshoot:a-sample-to-read-the-i2c-bus}}
samples/basic/touched
It is based on the Hynitron touchscreen code.
Mass reading 63 bytes was not possible.

I did add a write of 1 to register 0x00.


\subsubsection{a samples to handle semaphores}
\label{\detokenize{behind/troubleshoot:a-samples-to-handle-semaphores}}
samples/basic/testsemaphore


\section{placing a button on the screen}
\label{\detokenize{behind/lvglbutton:placing-a-button-on-the-screen}}\label{\detokenize{behind/lvglbutton::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{n}{sample} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{really} \PYG{n}{important}\PYG{p}{,} \PYG{n}{but} \PYG{n}{it} \PYG{n}{will} \PYG{n}{teach} \PYG{n}{you} \PYG{n}{that} \PYG{n}{you} \PYG{n}{need} \PYG{n}{to} \PYG{n+nb}{set} \PYG{n}{LVGL\PYGZus{}CONFIG} \PYG{n}{values}\PYG{p}{,} \PYG{o+ow}{in} \PYG{n}{order}    \PYG{n}{to} \PYG{n}{be} \PYG{n}{able} \PYG{n}{to} \PYG{n}{use} \PYG{n}{LVGL} \PYG{n}{functions}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Building and Running}
\label{\detokenize{behind/lvglbutton:building-and-running}}
In this repo under samples you will find an adapted gui/clock program.
A button from the LVGL library is placed on the screen.

Later on when the touch\sphinxhyphen{}screen driver is ready, we’ll be able to manipulate it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{Make sure that prj.conf file in clock directory contains the following:}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
CONFIG\_LVGL\_OBJ\_CONTAINER=y
CONFIG\_LVGL\_OBJ\_BUTTON=y
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

\sphinxstyleemphasis{problem} the canvas heigh*width eats up RAM and exceeds once \textgreater{} 40


\chapter{About}
\label{\detokenize{about:about}}\label{\detokenize{about::doc}}
I got a pinetime development kit very early.

I would like to thank the folks from \sphinxurl{https://www.pine64.org/}.

I like to hack stuff, and I like the idea behind Open Source.

The smartwatches I hacked, contained microcontrollers from Nordic Semiconductor.

A lot of resources exist for this breed.

It is an Arm based, 32bit microcontroller with a lot of flash and RAM memory.

In fact it is a small computer on your wrist, with a battery and screen, and capable of bluetooth 4+ wireless communication.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{n}{word} \PYG{n}{of} \PYG{n}{warning}\PYG{p}{:} \PYG{n}{this} \PYG{o+ow}{is} \PYG{n}{work} \PYG{o+ow}{in} \PYG{n}{progress}\PYG{o}{.}
\PYG{n}{You}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{re likely to have a better skillset then me.}
\PYG{n}{You} \PYG{n}{are} \PYG{n}{invited} \PYG{n}{to} \PYG{n}{add} \PYG{n}{the} \PYG{n}{missing} \PYG{n}{pieces} \PYG{o+ow}{and} \PYG{n}{to} \PYG{n}{improve} \PYG{n}{what}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s already there.}
\end{sphinxVerbatim}


\section{Todo}
\label{\detokenize{about:todo}}
list with suggestions:
\begin{itemize}
\item {} 
better graphics (lvgl using images and rotating stuff)

\item {} 
NOR flash (here one can store data)

\item {} 
watchdog

\item {} 
DFU (update over bluetooth)

\item {} 
acceleration sensor

\item {} 
heart rate sensor

\item {} 
fun stuff

\item {} 
useless stuff, but somehow cool

\item {} 
applications, e.g. calculator, cycle computer, step counter, heart attack predictor …

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}