samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
samples/index.rst:6: (Readme)  In each sample directory is a Readme file.
samples/basic/blinky/README.rst:16: (devicetree)  alias in their board devicetree description file. Doing so will generate
samples/basic/button/README.rst:9: (openocd)  With openocd or any other debugger you can peek at this location.
samples/basic/button/README.rst:26: (sw)  Alternatively, this could also be done by defining 'sw0' alias in the board
samples/basic/button/README.rst:26: (devicetree)  devicetree description file.
samples/basic/touchpoints/README.rst:4: (Touchpoints)  Touchpoints
samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/basic/touchpoints/README.rst:18: (touchpoint)  Only the first touchpoint is usable.
samples/basic/touchpoints/README.rst:26: (howto)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/touchpoints/README.rst:26: (touchpoints)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/scani2c/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/basic/scani2c/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/display/lvgl-posix/README.rst:18: (dev)  this is a posix sample - so no dev board necessary
samples/display/lvgl-posix/README.rst:26: (DCONF)  west build -p -b native_posix_64 samples/display/lvgl -DCONF=board/native-posix_64
samples/display/st7789v/README.rst:14: (grey)  in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (endian)  at any point then the LCD may be endian swapped).
samples/sensor/hrs3300/README.rst:15: (photodiode)  enable the green LED and measure the reflected light with a photodiode. The raw
samples/sensor/bma280/README.rst:4: (Accelerometer)  BMA280: Three Axis High-g I2C/SPI Accelerometer
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/bluetooth/peripheral/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/central_hr/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/eddystone/README.rst:10: (EID)  the definition of how Eddystone-EID beacons are configured and registered with
samples/bluetooth/eddystone/README.rst:20: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/peripheral-cts/README.rst:20: (bluetoothdevice)  a bluetoothdevice running the CTS service
samples/bluetooth/peripheral-cts/README.rst:24: (printk)  You will need a serial port to read the output of the "printk" messages.
samples/gui/clock/README.rst:13: (fn)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/clock/README.rst:13: (src)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/gfx/README.rst:4: (Adafruit)  Adafruit GFX Library on ST7789V Display
samples/gui/gfx/README.rst:9: (Adafruit)  This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.
samples/gui/lvtouch/README.rst:28: (lvtouch)  west build -p -b pinetime samples/gui/lvtouch
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (bosch)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/mgmt/smp_svr/README.rst:13: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_svr/README.rst:28: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_svr/README.rst:34: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_svr/README.rst:48: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_svr/README.rst:56: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_svr/README.rst:60: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_svr/README.rst:91: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:91: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:93: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_svr/README.rst:107: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_svr/README.rst:129: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:129: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:131: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_svr/README.rst:191: (Kconfig)  Kconfig option as described in 
samples/mgmt/smp_wtd/README.rst:19: (smp)  If not, a reset puts it back into smp-server mode, which allows you to upload again.
samples/mgmt/smp_wtd/README.rst:30: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_wtd/README.rst:45: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_wtd/README.rst:51: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_wtd/README.rst:65: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_wtd/README.rst:73: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_wtd/README.rst:77: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_wtd/README.rst:108: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:108: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:110: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_wtd/README.rst:124: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_wtd/README.rst:146: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:146: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:148: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_wtd/README.rst:208: (Kconfig)  Kconfig option as described in 
hacking/latexpdf.rst:2: (howto)  howto generate pdf documents
hacking/latexpdf.rst:2: (pdf)  howto generate pdf documents
hacking/latexpdf.rst:5: (pdf)  sphinx cannot generate pdf directly, and needs latex
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/i2cscanning.rst:54: (endvalue)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/openocd.rst:5: (howto)  howto use 2 openocd sessions
hacking/openocd.rst:5: (openocd)  howto use 2 openocd sessions
hacking/openocd.rst:35: (openocd)  Howto setup a second openocd session on a different port?
hacking/openocd.rst:47: (seperate)  This works really well, and does not require a seperate programmer.
hacking/flashing.rst:12: (swd)  The pinetime has a swd interface.
hacking/flashing.rst:12: (stm)  I use a stm-link which is very cheap(2$).
hacking/flashing.rst:19: (openocd)  To flash the software I use openocd :
hacking/flashing.rst:19: (stm)  example for stm-link usb-stick
hacking/flashing.rst:19: (usb)  example for stm-link usb-stick
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (usr)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (sysfsgpio)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (raspberrypi)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (cfg)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (swd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (usr)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (openocd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (cfg)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (bindto)  -c 'bindto 0.0.0.0'
hacking/flashing.rst:32: (openocd)  once you started the openocd background server, you can connect to it using:
hacking/infrastructure.rst:4: (howto)  howto configure gateway
hacking/writeprotection.rst:4: (howto)  howto flash your zephyr image
hacking/writeprotection.rst:26: (howto)  howto remove the write protection
hacking/writeprotection.rst:29: (dap)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:34: (Orangepi)  There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won't need an external programmer at all)
hacking/writeprotection.rst:34: (Openocd)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (cmsis)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (dap)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:38: (dap)  > nrf52.dap apreg 1 0x04 0x01
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/watchdog.rst:25: (fota)  if it cannot feed the watchdog, reset to fota, and you can upload another better version ...
drivers/bma421.rst:36: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:42: (Kconfig)  adapt Kconfig
drivers/bma421.rst:44: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:49: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/bma421.rst:49: (cp)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:53: (KConfig)  edit KConfig
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma280/Kconfig"
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma421/Kconfig"
drivers/bma421.rst:58: (bmc)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (magn)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (Kconfig)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:60: (bme)  source "drivers/sensor/bme280/Kconfig"
drivers/bma421.rst:60: (Kconfig)  source "drivers/sensor/bme280/Kconfig"
drivers/hrs3300.rst:26: (arduino)  I have used the settings of an arduino port of this library.
drivers/hrs3300.rst:38: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:38: (subdirectory)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:38: (ifdef)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:43: (Kconfig)  adapt Kconfig
drivers/hrs3300.rst:45: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:50: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/hrs3300.rst:50: (hx)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:50: (yaml)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:54: (KConfig)  edit KConfig
drivers/hrs3300.rst:56: (Kconfig)  source "drivers/sensor/hrs3300/Kconfig"
drivers/hrs3300.rst:98: (pdf)  HRS3300 Heart Rate Sensor.pdf
drivers/sensors.rst:5: (Accelerometer)  0x18: Accelerometer: BMA423-DS000
drivers/sensors.rst:11: (Hynitron)  0x15: Touch Controller: Hynitron CST816S Touch Controller
drivers/cst816s.rst:7: (hynitron)  the board definition file has been adapted slightly, using the focaltech ft5336 as a touch_controller. A minor change in this driver is enough to get data from the hynitron cst816S.
drivers/cst816s.rst:35: (Hynitron)  the Hynitron cst816s is a touchscreen.
drivers/cst816s.rst:47: (Kconfig)  adapt Kconfig
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/cst816s.rst:81: (lvtouch)  samples/gui/lvtouch (graphical)
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:22: (zephyrproject)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (spi)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (src)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:50: (spi)  complement the pinetime.dts file with the following (under spi)
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/spinor.rst:118: (macronix)  detect ID memory  : it is not the macronix one as suggestion on the pinetime website
drivers/spinor.rst:120: (jedec)  I found the following : jedec-id = [0b 40 16]; (OK: can execute sample program)
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
drivers/battery.rst:25: (adc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  saadc periodical calibration (spec suggests calibration if temperature changes by 10'C)
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (bosch)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:80: (lvaccel)  since no serial port and no J-LINK, I have to print messages to the screen (see sample gui/lvaccel)
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/behind-the-scene.rst:15: (bosch)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/touchscreen.rst:2: (Hynitron)  Touchscreen Hynitron
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:9: (behaviour)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:21: (behaviour)  This affect the behaviour of how threads are handled.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
behind/troubleshoot.rst:35: (threadhandling)  the threadhandling read the I2C-bus
behind/troubleshoot.rst:50: (testirq)  samples/basic/testirq
behind/troubleshoot.rst:65: (Hynitron)  It is based on the Hynitron touchscreen code.
behind/troubleshoot.rst:76: (testsemaphore)  samples/basic/testsemaphore
fota/signing.rst:10: (Bootloader)  The Bootloader is compiled with the public key.
fota/signing.rst:18: (keypair)  Generating a new keypair
fota/signing.rst:19: (keypair)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (keygen)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (subcommand)  subcommand:
fota/signing.rst:32: (keypair)  The generated keypair above contains both the public and the private
fota/signing.rst:32: (bootloader)  bootloader.
fota/signing.rst:47: (rsa)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/partitions.rst:39: (spi)  As the pinetime has an extra spi nor flash chip, we can use this.
fota/smp_svr.rst:12: (mcumgr)  This sample application supports the following mcumgr transports by default:
fota/smp_svr.rst:21: (smp)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:21: (mcumgr)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:23: (mcumgr)  Here is a procedure to install mcumgr on a raspberry pi  (or similar)
fota/smp_svr.rst:38: (smp)  So both slots need smp_svr software!
fota/smp_svr.rst:38: (svr)  So both slots need smp_svr software!
fota/smp_svr.rst:44: (smp)  Step 1: Build smp_svr
fota/smp_svr.rst:44: (svr)  Step 1: Build smp_svr
fota/smp_svr.rst:46: (nRF)   can be built for the nRF52 as follows:
fota/smp_svr.rst:78: (smp)  Step 3: Flash the smp_svr image
fota/smp_svr.rst:78: (svr)  Step 3: Flash the smp_svr image
fota/mcuboot.rst:12: (bootloader)  MCUboot   (a bootloader)
fota/mcuboot.rst:33: (github)  Clone MCUBOOT for zephyr from github.
fota/mcuboot.rst:33: (mcuboot)  Install additional packages required for development with mcuboot:
fota/mcuboot.rst:57: (bootloader)  After building the bootloader, the binaries should reside in
fota/mcuboot.rst:69: (Kconfig)   Kconfig variable, which must be enabled in
fota/mcuboot.rst:74: (bootable)  placement and generation in order for an application to be bootable by
fota/mcuboot.rst:98: (bootloader)  Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.
fota/mcuboot.rst:100: (openocd)  Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)
fota/mcuboot.rst:102: (bootloader)  at which point the bootloader should perform an upgrade.
samples/index.rst:6: (Readme)  In each sample directory is a Readme file.
samples/basic/blinky/README.rst:16: (devicetree)  alias in their board devicetree description file. Doing so will generate
samples/basic/button/README.rst:9: (openocd)  With openocd or any other debugger you can peek at this location.
samples/basic/button/README.rst:26: (sw)  Alternatively, this could also be done by defining 'sw0' alias in the board
samples/basic/button/README.rst:26: (devicetree)  devicetree description file.
samples/basic/touchpoints/README.rst:4: (Touchpoints)  Touchpoints
samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/basic/touchpoints/README.rst:18: (touchpoint)  Only the first touchpoint is usable.
samples/basic/touchpoints/README.rst:26: (howto)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/touchpoints/README.rst:26: (touchpoints)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/scani2c/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/basic/scani2c/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/display/lvgl-posix/README.rst:18: (dev)  this is a posix sample - so no dev board necessary
samples/display/lvgl-posix/README.rst:26: (DCONF)  west build -p -b native_posix_64 samples/display/lvgl -DCONF=board/native-posix_64
samples/display/st7789v/README.rst:14: (grey)  in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (endian)  at any point then the LCD may be endian swapped).
samples/sensor/hrs3300/README.rst:15: (photodiode)  enable the green LED and measure the reflected light with a photodiode. The raw
samples/sensor/bma280/README.rst:4: (Accelerometer)  BMA280: Three Axis High-g I2C/SPI Accelerometer
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/bluetooth/peripheral/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/central_hr/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/eddystone/README.rst:10: (EID)  the definition of how Eddystone-EID beacons are configured and registered with
samples/bluetooth/eddystone/README.rst:20: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/peripheral-cts/README.rst:20: (bluetoothdevice)  a bluetoothdevice running the CTS service
samples/bluetooth/peripheral-cts/README.rst:24: (printk)  You will need a serial port to read the output of the "printk" messages.
samples/gui/clock/README.rst:13: (fn)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/clock/README.rst:13: (src)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/gfx/README.rst:4: (Adafruit)  Adafruit GFX Library on ST7789V Display
samples/gui/gfx/README.rst:9: (Adafruit)  This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.
samples/gui/lvtouch/README.rst:28: (lvtouch)  west build -p -b pinetime samples/gui/lvtouch
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (bosch)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/mgmt/smp_svr/README.rst:13: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_svr/README.rst:28: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_svr/README.rst:34: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_svr/README.rst:48: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_svr/README.rst:56: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_svr/README.rst:60: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_svr/README.rst:91: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:91: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:93: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_svr/README.rst:107: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_svr/README.rst:129: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:129: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:131: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_svr/README.rst:191: (Kconfig)  Kconfig option as described in 
samples/mgmt/smp_wtd/README.rst:19: (smp)  If not, a reset puts it back into smp-server mode, which allows you to upload again.
samples/mgmt/smp_wtd/README.rst:30: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_wtd/README.rst:45: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_wtd/README.rst:51: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_wtd/README.rst:65: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_wtd/README.rst:73: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_wtd/README.rst:77: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_wtd/README.rst:108: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:108: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:110: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_wtd/README.rst:124: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_wtd/README.rst:146: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:146: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:148: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_wtd/README.rst:208: (Kconfig)  Kconfig option as described in 
hacking/latexpdf.rst:2: (howto)  howto generate pdf documents
hacking/latexpdf.rst:2: (pdf)  howto generate pdf documents
hacking/latexpdf.rst:5: (pdf)  sphinx cannot generate pdf directly, and needs latex
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/i2cscanning.rst:54: (endvalue)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/openocd.rst:5: (howto)  howto use 2 openocd sessions
hacking/openocd.rst:5: (openocd)  howto use 2 openocd sessions
hacking/openocd.rst:35: (openocd)  Howto setup a second openocd session on a different port?
hacking/openocd.rst:47: (seperate)  This works really well, and does not require a seperate programmer.
hacking/flashing.rst:12: (swd)  The pinetime has a swd interface.
hacking/flashing.rst:12: (stm)  I use a stm-link which is very cheap(2$).
hacking/flashing.rst:19: (openocd)  To flash the software I use openocd :
hacking/flashing.rst:19: (stm)  example for stm-link usb-stick
hacking/flashing.rst:19: (usb)  example for stm-link usb-stick
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (usr)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (sysfsgpio)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (raspberrypi)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (cfg)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (swd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (usr)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (openocd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (cfg)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (bindto)  -c 'bindto 0.0.0.0'
hacking/flashing.rst:32: (openocd)  once you started the openocd background server, you can connect to it using:
hacking/infrastructure.rst:4: (howto)  howto configure gateway
hacking/writeprotection.rst:4: (howto)  howto flash your zephyr image
hacking/writeprotection.rst:26: (howto)  howto remove the write protection
hacking/writeprotection.rst:29: (dap)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:34: (Orangepi)  There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won't need an external programmer at all)
hacking/writeprotection.rst:34: (Openocd)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (cmsis)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (dap)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:38: (dap)  > nrf52.dap apreg 1 0x04 0x01
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/watchdog.rst:25: (fota)  if it cannot feed the watchdog, reset to fota, and you can upload another better version ...
drivers/bma421.rst:36: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:42: (Kconfig)  adapt Kconfig
drivers/bma421.rst:44: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:49: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/bma421.rst:49: (cp)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:53: (KConfig)  edit KConfig
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma280/Kconfig"
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma421/Kconfig"
drivers/bma421.rst:58: (bmc)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (magn)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (Kconfig)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:60: (bme)  source "drivers/sensor/bme280/Kconfig"
drivers/bma421.rst:60: (Kconfig)  source "drivers/sensor/bme280/Kconfig"
drivers/hrs3300.rst:26: (arduino)  I have used the settings of an arduino port of this library.
drivers/hrs3300.rst:38: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:38: (subdirectory)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:38: (ifdef)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:43: (Kconfig)  adapt Kconfig
drivers/hrs3300.rst:45: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:50: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/hrs3300.rst:50: (hx)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:50: (yaml)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:54: (KConfig)  edit KConfig
drivers/hrs3300.rst:56: (Kconfig)  source "drivers/sensor/hrs3300/Kconfig"
drivers/hrs3300.rst:98: (pdf)  HRS3300 Heart Rate Sensor.pdf
drivers/sensors.rst:5: (Accelerometer)  0x18: Accelerometer: BMA423-DS000
drivers/sensors.rst:11: (Hynitron)  0x15: Touch Controller: Hynitron CST816S Touch Controller
drivers/cst816s.rst:7: (hynitron)  the board definition file has been adapted slightly, using the focaltech ft5336 as a touch_controller. A minor change in this driver is enough to get data from the hynitron cst816S.
drivers/cst816s.rst:35: (Hynitron)  the Hynitron cst816s is a touchscreen.
drivers/cst816s.rst:47: (Kconfig)  adapt Kconfig
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/cst816s.rst:81: (lvtouch)  samples/gui/lvtouch (graphical)
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:22: (zephyrproject)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (spi)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (src)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:50: (spi)  complement the pinetime.dts file with the following (under spi)
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/spinor.rst:118: (macronix)  detect ID memory  : it is not the macronix one as suggestion on the pinetime website
drivers/spinor.rst:120: (jedec)  I found the following : jedec-id = [0b 40 16]; (OK: can execute sample program)
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
drivers/battery.rst:25: (adc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  saadc periodical calibration (spec suggests calibration if temperature changes by 10'C)
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (bosch)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:80: (lvaccel)  since no serial port and no J-LINK, I have to print messages to the screen (see sample gui/lvaccel)
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/behind-the-scene.rst:15: (bosch)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/touchscreen.rst:2: (Hynitron)  Touchscreen Hynitron
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:9: (behaviour)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:21: (behaviour)  This affect the behaviour of how threads are handled.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
behind/troubleshoot.rst:35: (threadhandling)  the threadhandling read the I2C-bus
behind/troubleshoot.rst:50: (testirq)  samples/basic/testirq
behind/troubleshoot.rst:65: (Hynitron)  It is based on the Hynitron touchscreen code.
behind/troubleshoot.rst:76: (testsemaphore)  samples/basic/testsemaphore
fota/signing.rst:10: (Bootloader)  The Bootloader is compiled with the public key.
fota/signing.rst:18: (keypair)  Generating a new keypair
fota/signing.rst:19: (keypair)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (keygen)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (subcommand)  subcommand:
fota/signing.rst:32: (keypair)  The generated keypair above contains both the public and the private
fota/signing.rst:32: (bootloader)  bootloader.
fota/signing.rst:47: (rsa)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/partitions.rst:39: (spi)  As the pinetime has an extra spi nor flash chip, we can use this.
fota/smp_svr.rst:12: (mcumgr)  This sample application supports the following mcumgr transports by default:
fota/smp_svr.rst:21: (smp)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:21: (mcumgr)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:23: (mcumgr)  Here is a procedure to install mcumgr on a raspberry pi  (or similar)
fota/smp_svr.rst:38: (smp)  So both slots need smp_svr software!
fota/smp_svr.rst:38: (svr)  So both slots need smp_svr software!
fota/smp_svr.rst:44: (smp)  Step 1: Build smp_svr
fota/smp_svr.rst:44: (svr)  Step 1: Build smp_svr
fota/smp_svr.rst:46: (nRF)   can be built for the nRF52 as follows:
fota/smp_svr.rst:78: (smp)  Step 3: Flash the smp_svr image
fota/smp_svr.rst:78: (svr)  Step 3: Flash the smp_svr image
fota/mcuboot.rst:12: (bootloader)  MCUboot   (a bootloader)
fota/mcuboot.rst:33: (github)  Clone MCUBOOT for zephyr from github.
fota/mcuboot.rst:33: (mcuboot)  Install additional packages required for development with mcuboot:
fota/mcuboot.rst:57: (bootloader)  After building the bootloader, the binaries should reside in
fota/mcuboot.rst:69: (Kconfig)   Kconfig variable, which must be enabled in
fota/mcuboot.rst:74: (bootable)  placement and generation in order for an application to be bootable by
fota/mcuboot.rst:98: (bootloader)  Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.
fota/mcuboot.rst:100: (openocd)  Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)
fota/mcuboot.rst:102: (bootloader)  at which point the bootloader should perform an upgrade.
samples/index.rst:6: (Readme)  In each sample directory is a Readme file.
samples/basic/blinky/README.rst:16: (devicetree)  alias in their board devicetree description file. Doing so will generate
samples/basic/button/README.rst:9: (openocd)  With openocd or any other debugger you can peek at this location.
samples/basic/button/README.rst:26: (sw)  Alternatively, this could also be done by defining 'sw0' alias in the board
samples/basic/button/README.rst:26: (devicetree)  devicetree description file.
samples/basic/touchpoints/README.rst:4: (Touchpoints)  Touchpoints
samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/basic/touchpoints/README.rst:18: (touchpoint)  Only the first touchpoint is usable.
samples/basic/touchpoints/README.rst:26: (howto)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/touchpoints/README.rst:26: (touchpoints)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/scani2c/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/basic/scani2c/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/display/lvgl-posix/README.rst:18: (dev)  this is a posix sample - so no dev board necessary
samples/display/lvgl-posix/README.rst:26: (DCONF)  west build -p -b native_posix_64 samples/display/lvgl -DCONF=board/native-posix_64
samples/display/st7789v/README.rst:14: (grey)  in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (endian)  at any point then the LCD may be endian swapped).
samples/sensor/hrs3300/README.rst:15: (photodiode)  enable the green LED and measure the reflected light with a photodiode. The raw
samples/sensor/bma280/README.rst:4: (Accelerometer)  BMA280: Three Axis High-g I2C/SPI Accelerometer
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/bluetooth/peripheral/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/central_hr/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/eddystone/README.rst:10: (EID)  the definition of how Eddystone-EID beacons are configured and registered with
samples/bluetooth/eddystone/README.rst:20: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/peripheral-cts/README.rst:20: (bluetoothdevice)  a bluetoothdevice running the CTS service
samples/bluetooth/peripheral-cts/README.rst:24: (printk)  You will need a serial port to read the output of the "printk" messages.
samples/gui/clock/README.rst:13: (fn)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/clock/README.rst:13: (src)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/gfx/README.rst:4: (Adafruit)  Adafruit GFX Library on ST7789V Display
samples/gui/gfx/README.rst:9: (Adafruit)  This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.
samples/gui/lvtouch/README.rst:28: (lvtouch)  west build -p -b pinetime samples/gui/lvtouch
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (bosch)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/mgmt/smp_svr/README.rst:13: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_svr/README.rst:28: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_svr/README.rst:34: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_svr/README.rst:48: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_svr/README.rst:56: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_svr/README.rst:60: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_svr/README.rst:91: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:91: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:93: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_svr/README.rst:107: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_svr/README.rst:129: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:129: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:131: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_svr/README.rst:191: (Kconfig)  Kconfig option as described in 
samples/mgmt/smp_wtd/README.rst:19: (smp)  If not, a reset puts it back into smp-server mode, which allows you to upload again.
samples/mgmt/smp_wtd/README.rst:30: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_wtd/README.rst:45: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_wtd/README.rst:51: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_wtd/README.rst:65: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_wtd/README.rst:73: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_wtd/README.rst:77: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_wtd/README.rst:108: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:108: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:110: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_wtd/README.rst:124: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_wtd/README.rst:146: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:146: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:148: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_wtd/README.rst:208: (Kconfig)  Kconfig option as described in 
hacking/latexpdf.rst:2: (howto)  howto generate pdf documents
hacking/latexpdf.rst:2: (pdf)  howto generate pdf documents
hacking/latexpdf.rst:5: (pdf)  sphinx cannot generate pdf directly, and needs latex
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/i2cscanning.rst:54: (endvalue)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/openocd.rst:5: (howto)  howto use 2 openocd sessions
hacking/openocd.rst:5: (openocd)  howto use 2 openocd sessions
hacking/openocd.rst:35: (openocd)  Howto setup a second openocd session on a different port?
hacking/openocd.rst:47: (seperate)  This works really well, and does not require a seperate programmer.
hacking/flashing.rst:12: (swd)  The pinetime has a swd interface.
hacking/flashing.rst:12: (stm)  I use a stm-link which is very cheap(2$).
hacking/flashing.rst:19: (openocd)  To flash the software I use openocd :
hacking/flashing.rst:19: (stm)  example for stm-link usb-stick
hacking/flashing.rst:19: (usb)  example for stm-link usb-stick
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (usr)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (sysfsgpio)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (raspberrypi)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (cfg)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (swd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (usr)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (openocd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (cfg)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (bindto)  -c 'bindto 0.0.0.0'
hacking/flashing.rst:32: (openocd)  once you started the openocd background server, you can connect to it using:
hacking/infrastructure.rst:4: (howto)  howto configure gateway
hacking/writeprotection.rst:4: (howto)  howto flash your zephyr image
hacking/writeprotection.rst:26: (howto)  howto remove the write protection
hacking/writeprotection.rst:29: (dap)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:34: (Orangepi)  There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won't need an external programmer at all)
hacking/writeprotection.rst:34: (Openocd)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (cmsis)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (dap)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:38: (dap)  > nrf52.dap apreg 1 0x04 0x01
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/watchdog.rst:25: (fota)  if it cannot feed the watchdog, reset to fota, and you can upload another better version ...
drivers/bma421.rst:36: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:42: (Kconfig)  adapt Kconfig
drivers/bma421.rst:44: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:49: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/bma421.rst:49: (cp)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:53: (KConfig)  edit KConfig
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma280/Kconfig"
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma421/Kconfig"
drivers/bma421.rst:58: (bmc)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (magn)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (Kconfig)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:60: (bme)  source "drivers/sensor/bme280/Kconfig"
drivers/bma421.rst:60: (Kconfig)  source "drivers/sensor/bme280/Kconfig"
drivers/hrs3300.rst:26: (arduino)  I have used the settings of an arduino port of this library.
drivers/hrs3300.rst:38: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:38: (subdirectory)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:38: (ifdef)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:43: (Kconfig)  adapt Kconfig
drivers/hrs3300.rst:45: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:50: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/hrs3300.rst:50: (hx)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:50: (yaml)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:54: (KConfig)  edit KConfig
drivers/hrs3300.rst:56: (Kconfig)  source "drivers/sensor/hrs3300/Kconfig"
drivers/hrs3300.rst:98: (pdf)  HRS3300 Heart Rate Sensor.pdf
drivers/sensors.rst:5: (Accelerometer)  0x18: Accelerometer: BMA423-DS000
drivers/sensors.rst:11: (Hynitron)  0x15: Touch Controller: Hynitron CST816S Touch Controller
drivers/cst816s.rst:7: (hynitron)  the board definition file has been adapted slightly, using the focaltech ft5336 as a touch_controller. A minor change in this driver is enough to get data from the hynitron cst816S.
drivers/cst816s.rst:35: (Hynitron)  the Hynitron cst816s is a touchscreen.
drivers/cst816s.rst:47: (Kconfig)  adapt Kconfig
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/cst816s.rst:81: (lvtouch)  samples/gui/lvtouch (graphical)
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:22: (zephyrproject)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (spi)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (src)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:50: (spi)  complement the pinetime.dts file with the following (under spi)
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/spinor.rst:118: (macronix)  detect ID memory  : it is not the macronix one as suggestion on the pinetime website
drivers/spinor.rst:120: (jedec)  I found the following : jedec-id = [0b 40 16]; (OK: can execute sample program)
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
drivers/battery.rst:25: (adc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  saadc periodical calibration (spec suggests calibration if temperature changes by 10'C)
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (bosch)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:80: (lvaccel)  since no serial port and no J-LINK, I have to print messages to the screen (see sample gui/lvaccel)
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/behind-the-scene.rst:15: (bosch)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/touchscreen.rst:2: (Hynitron)  Touchscreen Hynitron
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:9: (behaviour)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:21: (behaviour)  This affect the behaviour of how threads are handled.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
behind/troubleshoot.rst:35: (threadhandling)  the threadhandling read the I2C-bus
behind/troubleshoot.rst:50: (testirq)  samples/basic/testirq
behind/troubleshoot.rst:65: (Hynitron)  It is based on the Hynitron touchscreen code.
behind/troubleshoot.rst:76: (testsemaphore)  samples/basic/testsemaphore
fota/signing.rst:10: (Bootloader)  The Bootloader is compiled with the public key.
fota/signing.rst:18: (keypair)  Generating a new keypair
fota/signing.rst:19: (keypair)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (keygen)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (subcommand)  subcommand:
fota/signing.rst:32: (keypair)  The generated keypair above contains both the public and the private
fota/signing.rst:32: (bootloader)  bootloader.
fota/signing.rst:47: (rsa)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/partitions.rst:39: (spi)  As the pinetime has an extra spi nor flash chip, we can use this.
fota/smp_svr.rst:12: (mcumgr)  This sample application supports the following mcumgr transports by default:
fota/smp_svr.rst:21: (smp)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:21: (mcumgr)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:23: (mcumgr)  Here is a procedure to install mcumgr on a raspberry pi  (or similar)
fota/smp_svr.rst:38: (smp)  So both slots need smp_svr software!
fota/smp_svr.rst:38: (svr)  So both slots need smp_svr software!
fota/smp_svr.rst:44: (smp)  Step 1: Build smp_svr
fota/smp_svr.rst:44: (svr)  Step 1: Build smp_svr
fota/smp_svr.rst:46: (nRF)   can be built for the nRF52 as follows:
fota/smp_svr.rst:78: (smp)  Step 3: Flash the smp_svr image
fota/smp_svr.rst:78: (svr)  Step 3: Flash the smp_svr image
fota/mcuboot.rst:12: (bootloader)  MCUboot   (a bootloader)
fota/mcuboot.rst:33: (github)  Clone MCUBOOT for zephyr from github.
fota/mcuboot.rst:33: (mcuboot)  Install additional packages required for development with mcuboot:
fota/mcuboot.rst:57: (bootloader)  After building the bootloader, the binaries should reside in
fota/mcuboot.rst:69: (Kconfig)   Kconfig variable, which must be enabled in
fota/mcuboot.rst:74: (bootable)  placement and generation in order for an application to be bootable by
fota/mcuboot.rst:98: (bootloader)  Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.
fota/mcuboot.rst:100: (openocd)  Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)
fota/mcuboot.rst:102: (bootloader)  at which point the bootloader should perform an upgrade.
samples/index.rst:6: (Readme)  In each sample directory is a Readme file.
samples/basic/blinky/README.rst:16: (devicetree)  alias in their board devicetree description file. Doing so will generate
samples/basic/button/README.rst:9: (openocd)  With openocd or any other debugger you can peek at this location.
samples/basic/button/README.rst:26: (sw)  Alternatively, this could also be done by defining 'sw0' alias in the board
samples/basic/button/README.rst:26: (devicetree)  devicetree description file.
samples/basic/touchpoints/README.rst:4: (Touchpoints)  Touchpoints
samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/basic/touchpoints/README.rst:18: (touchpoint)  Only the first touchpoint is usable.
samples/basic/touchpoints/README.rst:26: (howto)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/touchpoints/README.rst:26: (touchpoints)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/scani2c/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/basic/scani2c/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/display/lvgl-posix/README.rst:18: (dev)  this is a posix sample - so no dev board necessary
samples/display/lvgl-posix/README.rst:26: (DCONF)  west build -p -b native_posix_64 samples/display/lvgl -DCONF=board/native-posix_64
samples/display/st7789v/README.rst:14: (grey)  in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (endian)  at any point then the LCD may be endian swapped).
samples/sensor/hrs3300/README.rst:15: (photodiode)  enable the green LED and measure the reflected light with a photodiode. The raw
samples/sensor/bma280/README.rst:4: (Accelerometer)  BMA280: Three Axis High-g I2C/SPI Accelerometer
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/bluetooth/peripheral/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/central_hr/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/eddystone/README.rst:10: (EID)  the definition of how Eddystone-EID beacons are configured and registered with
samples/bluetooth/eddystone/README.rst:20: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/peripheral-cts/README.rst:20: (bluetoothdevice)  a bluetoothdevice running the CTS service
samples/bluetooth/peripheral-cts/README.rst:24: (printk)  You will need a serial port to read the output of the "printk" messages.
samples/gui/clock/README.rst:13: (fn)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/clock/README.rst:13: (src)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/gfx/README.rst:4: (Adafruit)  Adafruit GFX Library on ST7789V Display
samples/gui/gfx/README.rst:9: (Adafruit)  This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.
samples/gui/lvtouch/README.rst:28: (lvtouch)  west build -p -b pinetime samples/gui/lvtouch
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (bosch)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/mgmt/smp_svr/README.rst:13: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_svr/README.rst:28: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_svr/README.rst:34: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_svr/README.rst:48: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_svr/README.rst:56: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_svr/README.rst:60: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_svr/README.rst:91: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:91: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:93: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_svr/README.rst:107: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_svr/README.rst:129: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:129: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:131: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_svr/README.rst:191: (Kconfig)  Kconfig option as described in 
samples/mgmt/smp_wtd/README.rst:19: (smp)  If not, a reset puts it back into smp-server mode, which allows you to upload again.
samples/mgmt/smp_wtd/README.rst:30: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_wtd/README.rst:45: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_wtd/README.rst:51: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_wtd/README.rst:65: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_wtd/README.rst:73: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_wtd/README.rst:77: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_wtd/README.rst:108: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:108: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:110: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_wtd/README.rst:124: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_wtd/README.rst:146: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:146: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:148: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_wtd/README.rst:208: (Kconfig)  Kconfig option as described in 
hacking/latexpdf.rst:2: (howto)  howto generate pdf documents
hacking/latexpdf.rst:2: (pdf)  howto generate pdf documents
hacking/latexpdf.rst:5: (pdf)  sphinx cannot generate pdf directly, and needs latex
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/i2cscanning.rst:54: (endvalue)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/openocd.rst:5: (howto)  howto use 2 openocd sessions
hacking/openocd.rst:5: (openocd)  howto use 2 openocd sessions
hacking/openocd.rst:35: (openocd)  Howto setup a second openocd session on a different port?
hacking/openocd.rst:47: (seperate)  This works really well, and does not require a seperate programmer.
hacking/flashing.rst:12: (swd)  The pinetime has a swd interface.
hacking/flashing.rst:12: (stm)  I use a stm-link which is very cheap(2$).
hacking/flashing.rst:19: (openocd)  To flash the software I use openocd :
hacking/flashing.rst:19: (stm)  example for stm-link usb-stick
hacking/flashing.rst:19: (usb)  example for stm-link usb-stick
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (usr)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (sysfsgpio)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (raspberrypi)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (cfg)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (swd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (usr)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (openocd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (cfg)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (bindto)  -c 'bindto 0.0.0.0'
hacking/flashing.rst:32: (openocd)  once you started the openocd background server, you can connect to it using:
hacking/infrastructure.rst:4: (howto)  howto configure gateway
hacking/writeprotection.rst:4: (howto)  howto flash your zephyr image
hacking/writeprotection.rst:26: (howto)  howto remove the write protection
hacking/writeprotection.rst:29: (dap)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:34: (Orangepi)  There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won't need an external programmer at all)
hacking/writeprotection.rst:34: (Openocd)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (cmsis)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (dap)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:38: (dap)  > nrf52.dap apreg 1 0x04 0x01
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/watchdog.rst:25: (fota)  if it cannot feed the watchdog, reset to fota, and you can upload another better version ...
drivers/bma421.rst:36: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:42: (Kconfig)  adapt Kconfig
drivers/bma421.rst:44: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:49: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/bma421.rst:49: (cp)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:53: (KConfig)  edit KConfig
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma280/Kconfig"
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma421/Kconfig"
drivers/bma421.rst:58: (bmc)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (magn)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (Kconfig)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:60: (bme)  source "drivers/sensor/bme280/Kconfig"
drivers/bma421.rst:60: (Kconfig)  source "drivers/sensor/bme280/Kconfig"
drivers/hrs3300.rst:26: (arduino)  I have used the settings of an arduino port of this library.
drivers/hrs3300.rst:38: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:38: (subdirectory)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:38: (ifdef)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:43: (Kconfig)  adapt Kconfig
drivers/hrs3300.rst:45: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:50: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/hrs3300.rst:50: (hx)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:50: (yaml)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:54: (KConfig)  edit KConfig
drivers/hrs3300.rst:56: (Kconfig)  source "drivers/sensor/hrs3300/Kconfig"
drivers/hrs3300.rst:98: (pdf)  HRS3300 Heart Rate Sensor.pdf
drivers/sensors.rst:5: (Accelerometer)  0x18: Accelerometer: BMA423-DS000
drivers/sensors.rst:11: (Hynitron)  0x15: Touch Controller: Hynitron CST816S Touch Controller
drivers/cst816s.rst:7: (hynitron)  the board definition file has been adapted slightly, using the focaltech ft5336 as a touch_controller. A minor change in this driver is enough to get data from the hynitron cst816S.
drivers/cst816s.rst:35: (Hynitron)  the Hynitron cst816s is a touchscreen.
drivers/cst816s.rst:47: (Kconfig)  adapt Kconfig
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/cst816s.rst:81: (lvtouch)  samples/gui/lvtouch (graphical)
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:22: (zephyrproject)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (spi)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (src)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:50: (spi)  complement the pinetime.dts file with the following (under spi)
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/spinor.rst:118: (macronix)  detect ID memory  : it is not the macronix one as suggestion on the pinetime website
drivers/spinor.rst:120: (jedec)  I found the following : jedec-id = [0b 40 16]; (OK: can execute sample program)
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
drivers/battery.rst:25: (adc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  saadc periodical calibration (spec suggests calibration if temperature changes by 10'C)
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (bosch)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:80: (lvaccel)  since no serial port and no J-LINK, I have to print messages to the screen (see sample gui/lvaccel)
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/behind-the-scene.rst:15: (bosch)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/touchscreen.rst:2: (Hynitron)  Touchscreen Hynitron
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:9: (behaviour)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:21: (behaviour)  This affect the behaviour of how threads are handled.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
behind/troubleshoot.rst:35: (threadhandling)  the threadhandling read the I2C-bus
behind/troubleshoot.rst:50: (testirq)  samples/basic/testirq
behind/troubleshoot.rst:65: (Hynitron)  It is based on the Hynitron touchscreen code.
behind/troubleshoot.rst:76: (testsemaphore)  samples/basic/testsemaphore
fota/signing.rst:10: (Bootloader)  The Bootloader is compiled with the public key.
fota/signing.rst:18: (keypair)  Generating a new keypair
fota/signing.rst:19: (keypair)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (keygen)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (subcommand)  subcommand:
fota/signing.rst:32: (keypair)  The generated keypair above contains both the public and the private
fota/signing.rst:32: (bootloader)  bootloader.
fota/signing.rst:47: (rsa)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/partitions.rst:39: (spi)  As the pinetime has an extra spi nor flash chip, we can use this.
fota/smp_svr.rst:12: (mcumgr)  This sample application supports the following mcumgr transports by default:
fota/smp_svr.rst:21: (smp)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:21: (mcumgr)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:23: (mcumgr)  Here is a procedure to install mcumgr on a raspberry pi  (or similar)
fota/smp_svr.rst:38: (smp)  So both slots need smp_svr software!
fota/smp_svr.rst:38: (svr)  So both slots need smp_svr software!
fota/smp_svr.rst:44: (smp)  Step 1: Build smp_svr
fota/smp_svr.rst:44: (svr)  Step 1: Build smp_svr
fota/smp_svr.rst:46: (nRF)   can be built for the nRF52 as follows:
fota/smp_svr.rst:78: (smp)  Step 3: Flash the smp_svr image
fota/smp_svr.rst:78: (svr)  Step 3: Flash the smp_svr image
fota/mcuboot.rst:12: (bootloader)  MCUboot   (a bootloader)
fota/mcuboot.rst:33: (github)  Clone MCUBOOT for zephyr from github.
fota/mcuboot.rst:33: (mcuboot)  Install additional packages required for development with mcuboot:
fota/mcuboot.rst:57: (bootloader)  After building the bootloader, the binaries should reside in
fota/mcuboot.rst:69: (Kconfig)   Kconfig variable, which must be enabled in
fota/mcuboot.rst:74: (bootable)  placement and generation in order for an application to be bootable by
fota/mcuboot.rst:98: (bootloader)  Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.
fota/mcuboot.rst:100: (openocd)  Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)
fota/mcuboot.rst:102: (bootloader)  at which point the bootloader should perform an upgrade.
samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
samples/index.rst:6: (Readme)  In each sample directory is a Readme file.
samples/basic/blinky/README.rst:16: (devicetree)  alias in their board devicetree description file. Doing so will generate
samples/basic/button/README.rst:9: (openocd)  With openocd or any other debugger you can peek at this location.
samples/basic/button/README.rst:26: (sw)  Alternatively, this could also be done by defining 'sw0' alias in the board
samples/basic/button/README.rst:26: (devicetree)  devicetree description file.
samples/basic/touchpoints/README.rst:4: (Touchpoints)  Touchpoints
samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/basic/touchpoints/README.rst:18: (touchpoint)  Only the first touchpoint is usable.
samples/basic/touchpoints/README.rst:26: (howto)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/touchpoints/README.rst:26: (touchpoints)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/scani2c/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/basic/scani2c/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/display/lvgl-posix/README.rst:18: (dev)  this is a posix sample - so no dev board necessary
samples/display/lvgl-posix/README.rst:26: (DCONF)  west build -p -b native_posix_64 samples/display/lvgl -DCONF=board/native-posix_64
samples/display/st7789v/README.rst:14: (grey)  in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (endian)  at any point then the LCD may be endian swapped).
samples/sensor/hrs3300/README.rst:15: (photodiode)  enable the green LED and measure the reflected light with a photodiode. The raw
samples/sensor/bma280/README.rst:4: (Accelerometer)  BMA280: Three Axis High-g I2C/SPI Accelerometer
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/bluetooth/peripheral/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/central_hr/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/eddystone/README.rst:10: (EID)  the definition of how Eddystone-EID beacons are configured and registered with
samples/bluetooth/eddystone/README.rst:20: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/peripheral-cts/README.rst:20: (bluetoothdevice)  a bluetoothdevice running the CTS service
samples/bluetooth/peripheral-cts/README.rst:24: (printk)  You will need a serial port to read the output of the "printk" messages.
samples/gui/clock/README.rst:13: (fn)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/clock/README.rst:13: (src)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/gfx/README.rst:4: (Adafruit)  Adafruit GFX Library on ST7789V Display
samples/gui/gfx/README.rst:9: (Adafruit)  This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.
samples/gui/lvtouch/README.rst:28: (lvtouch)  west build -p -b pinetime samples/gui/lvtouch
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (bosch)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/mgmt/smp_svr/README.rst:13: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_svr/README.rst:28: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_svr/README.rst:34: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_svr/README.rst:48: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_svr/README.rst:56: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_svr/README.rst:60: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_svr/README.rst:91: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:91: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:93: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_svr/README.rst:107: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_svr/README.rst:129: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:129: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:131: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_svr/README.rst:191: (Kconfig)  Kconfig option as described in 
samples/mgmt/smp_wtd/README.rst:19: (smp)  If not, a reset puts it back into smp-server mode, which allows you to upload again.
samples/mgmt/smp_wtd/README.rst:30: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_wtd/README.rst:45: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_wtd/README.rst:51: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_wtd/README.rst:65: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_wtd/README.rst:73: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_wtd/README.rst:77: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_wtd/README.rst:108: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:108: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:110: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_wtd/README.rst:124: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_wtd/README.rst:146: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:146: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:148: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_wtd/README.rst:208: (Kconfig)  Kconfig option as described in 
hacking/latexpdf.rst:2: (howto)  howto generate pdf documents
hacking/latexpdf.rst:2: (pdf)  howto generate pdf documents
hacking/latexpdf.rst:5: (pdf)  sphinx cannot generate pdf directly, and needs latex
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/i2cscanning.rst:54: (endvalue)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/openocd.rst:5: (howto)  howto use 2 openocd sessions
hacking/openocd.rst:5: (openocd)  howto use 2 openocd sessions
hacking/openocd.rst:35: (openocd)  Howto setup a second openocd session on a different port?
hacking/openocd.rst:47: (seperate)  This works really well, and does not require a seperate programmer.
hacking/flashing.rst:12: (swd)  The pinetime has a swd interface.
hacking/flashing.rst:12: (stm)  I use a stm-link which is very cheap(2$).
hacking/flashing.rst:19: (openocd)  To flash the software I use openocd :
hacking/flashing.rst:19: (stm)  example for stm-link usb-stick
hacking/flashing.rst:19: (usb)  example for stm-link usb-stick
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (usr)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (sysfsgpio)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (raspberrypi)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (cfg)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (swd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (usr)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (openocd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (cfg)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (bindto)  -c 'bindto 0.0.0.0'
hacking/flashing.rst:32: (openocd)  once you started the openocd background server, you can connect to it using:
hacking/infrastructure.rst:4: (howto)  howto configure gateway
hacking/writeprotection.rst:4: (howto)  howto flash your zephyr image
hacking/writeprotection.rst:26: (howto)  howto remove the write protection
hacking/writeprotection.rst:29: (dap)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:34: (Orangepi)  There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won't need an external programmer at all)
hacking/writeprotection.rst:34: (Openocd)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (cmsis)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (dap)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:38: (dap)  > nrf52.dap apreg 1 0x04 0x01
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/watchdog.rst:25: (fota)  if it cannot feed the watchdog, reset to fota, and you can upload another better version ...
drivers/bma421.rst:36: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:42: (Kconfig)  adapt Kconfig
drivers/bma421.rst:44: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:49: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/bma421.rst:49: (cp)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:53: (KConfig)  edit KConfig
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma280/Kconfig"
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma421/Kconfig"
drivers/bma421.rst:58: (bmc)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (magn)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (Kconfig)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:60: (bme)  source "drivers/sensor/bme280/Kconfig"
drivers/bma421.rst:60: (Kconfig)  source "drivers/sensor/bme280/Kconfig"
drivers/hrs3300.rst:26: (arduino)  I have used the settings of an arduino port of this library.
drivers/hrs3300.rst:38: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:38: (subdirectory)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:38: (ifdef)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:43: (Kconfig)  adapt Kconfig
drivers/hrs3300.rst:45: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:50: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/hrs3300.rst:50: (hx)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:50: (yaml)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:54: (KConfig)  edit KConfig
drivers/hrs3300.rst:56: (Kconfig)  source "drivers/sensor/hrs3300/Kconfig"
drivers/hrs3300.rst:98: (pdf)  HRS3300 Heart Rate Sensor.pdf
drivers/sensors.rst:5: (Accelerometer)  0x18: Accelerometer: BMA423-DS000
drivers/sensors.rst:11: (Hynitron)  0x15: Touch Controller: Hynitron CST816S Touch Controller
drivers/cst816s.rst:7: (hynitron)  the board definition file has been adapted slightly, using the focaltech ft5336 as a touch_controller. A minor change in this driver is enough to get data from the hynitron cst816S.
drivers/cst816s.rst:35: (Hynitron)  the Hynitron cst816s is a touchscreen.
drivers/cst816s.rst:47: (Kconfig)  adapt Kconfig
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/cst816s.rst:81: (lvtouch)  samples/gui/lvtouch (graphical)
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:22: (zephyrproject)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (spi)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (src)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:50: (spi)  complement the pinetime.dts file with the following (under spi)
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/spinor.rst:118: (macronix)  detect ID memory  : it is not the macronix one as suggestion on the pinetime website
drivers/spinor.rst:120: (jedec)  I found the following : jedec-id = [0b 40 16]; (OK: can execute sample program)
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
drivers/battery.rst:25: (adc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  saadc periodical calibration (spec suggests calibration if temperature changes by 10'C)
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (bosch)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:80: (lvaccel)  since no serial port and no J-LINK, I have to print messages to the screen (see sample gui/lvaccel)
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/behind-the-scene.rst:15: (bosch)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/touchscreen.rst:2: (Hynitron)  Touchscreen Hynitron
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:9: (behaviour)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:21: (behaviour)  This affect the behaviour of how threads are handled.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
behind/troubleshoot.rst:35: (threadhandling)  the threadhandling read the I2C-bus
behind/troubleshoot.rst:50: (testirq)  samples/basic/testirq
behind/troubleshoot.rst:65: (Hynitron)  It is based on the Hynitron touchscreen code.
behind/troubleshoot.rst:76: (testsemaphore)  samples/basic/testsemaphore
fota/signing.rst:10: (Bootloader)  The Bootloader is compiled with the public key.
fota/signing.rst:18: (keypair)  Generating a new keypair
fota/signing.rst:19: (keypair)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (keygen)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (subcommand)  subcommand:
fota/signing.rst:32: (keypair)  The generated keypair above contains both the public and the private
fota/signing.rst:32: (bootloader)  bootloader.
fota/signing.rst:47: (rsa)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/partitions.rst:39: (spi)  As the pinetime has an extra spi nor flash chip, we can use this.
fota/smp_svr.rst:12: (mcumgr)  This sample application supports the following mcumgr transports by default:
fota/smp_svr.rst:21: (smp)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:21: (mcumgr)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:23: (mcumgr)  Here is a procedure to install mcumgr on a raspberry pi  (or similar)
fota/smp_svr.rst:38: (smp)  So both slots need smp_svr software!
fota/smp_svr.rst:38: (svr)  So both slots need smp_svr software!
fota/smp_svr.rst:44: (smp)  Step 1: Build smp_svr
fota/smp_svr.rst:44: (svr)  Step 1: Build smp_svr
fota/smp_svr.rst:46: (nRF)   can be built for the nRF52 as follows:
fota/smp_svr.rst:78: (smp)  Step 3: Flash the smp_svr image
fota/smp_svr.rst:78: (svr)  Step 3: Flash the smp_svr image
fota/mcuboot.rst:12: (bootloader)  MCUboot   (a bootloader)
fota/mcuboot.rst:33: (github)  Clone MCUBOOT for zephyr from github.
fota/mcuboot.rst:33: (mcuboot)  Install additional packages required for development with mcuboot:
fota/mcuboot.rst:57: (bootloader)  After building the bootloader, the binaries should reside in
fota/mcuboot.rst:69: (Kconfig)   Kconfig variable, which must be enabled in
fota/mcuboot.rst:74: (bootable)  placement and generation in order for an application to be bootable by
fota/mcuboot.rst:98: (bootloader)  Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.
fota/mcuboot.rst:100: (openocd)  Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)
fota/mcuboot.rst:102: (bootloader)  at which point the bootloader should perform an upgrade.
samples/index.rst:6: (Readme)  In each sample directory is a Readme file.
samples/basic/blinky/README.rst:16: (devicetree)  alias in their board devicetree description file. Doing so will generate
samples/basic/button/README.rst:9: (openocd)  With openocd or any other debugger you can peek at this location.
samples/basic/button/README.rst:26: (sw)  Alternatively, this could also be done by defining 'sw0' alias in the board
samples/basic/button/README.rst:26: (devicetree)  devicetree description file.
samples/basic/touchpoints/README.rst:4: (Touchpoints)  Touchpoints
samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/basic/touchpoints/README.rst:18: (touchpoint)  Only the first touchpoint is usable.
samples/basic/touchpoints/README.rst:26: (howto)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/touchpoints/README.rst:26: (touchpoints)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/scani2c/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/basic/scani2c/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/display/lvgl-posix/README.rst:18: (dev)  this is a posix sample - so no dev board necessary
samples/display/lvgl-posix/README.rst:26: (DCONF)  west build -p -b native_posix_64 samples/display/lvgl -DCONF=board/native-posix_64
samples/display/st7789v/README.rst:14: (grey)  in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (endian)  at any point then the LCD may be endian swapped).
samples/sensor/hrs3300/README.rst:15: (photodiode)  enable the green LED and measure the reflected light with a photodiode. The raw
samples/sensor/bma280/README.rst:4: (Accelerometer)  BMA280: Three Axis High-g I2C/SPI Accelerometer
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/bluetooth/peripheral/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/central_hr/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/eddystone/README.rst:10: (EID)  the definition of how Eddystone-EID beacons are configured and registered with
samples/bluetooth/eddystone/README.rst:20: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/peripheral-cts/README.rst:20: (bluetoothdevice)  a bluetoothdevice running the CTS service
samples/bluetooth/peripheral-cts/README.rst:24: (printk)  You will need a serial port to read the output of the "printk" messages.
samples/gui/clock/README.rst:13: (fn)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/clock/README.rst:13: (src)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/gfx/README.rst:4: (Adafruit)  Adafruit GFX Library on ST7789V Display
samples/gui/gfx/README.rst:9: (Adafruit)  This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.
samples/gui/lvtouch/README.rst:28: (lvtouch)  west build -p -b pinetime samples/gui/lvtouch
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (bosch)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/mgmt/smp_svr/README.rst:13: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_svr/README.rst:28: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_svr/README.rst:34: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_svr/README.rst:48: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_svr/README.rst:56: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_svr/README.rst:60: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_svr/README.rst:91: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:91: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:93: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_svr/README.rst:107: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_svr/README.rst:129: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:129: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:131: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_svr/README.rst:191: (Kconfig)  Kconfig option as described in 
samples/mgmt/smp_wtd/README.rst:19: (smp)  If not, a reset puts it back into smp-server mode, which allows you to upload again.
samples/mgmt/smp_wtd/README.rst:30: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_wtd/README.rst:45: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_wtd/README.rst:51: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_wtd/README.rst:65: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_wtd/README.rst:73: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_wtd/README.rst:77: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_wtd/README.rst:108: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:108: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:110: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_wtd/README.rst:124: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_wtd/README.rst:146: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:146: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:148: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_wtd/README.rst:208: (Kconfig)  Kconfig option as described in 
hacking/latexpdf.rst:2: (howto)  howto generate pdf documents
hacking/latexpdf.rst:2: (pdf)  howto generate pdf documents
hacking/latexpdf.rst:5: (pdf)  sphinx cannot generate pdf directly, and needs latex
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/i2cscanning.rst:54: (endvalue)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/openocd.rst:5: (howto)  howto use 2 openocd sessions
hacking/openocd.rst:5: (openocd)  howto use 2 openocd sessions
hacking/openocd.rst:35: (openocd)  Howto setup a second openocd session on a different port?
hacking/openocd.rst:47: (seperate)  This works really well, and does not require a seperate programmer.
hacking/flashing.rst:12: (swd)  The pinetime has a swd interface.
hacking/flashing.rst:12: (stm)  I use a stm-link which is very cheap(2$).
hacking/flashing.rst:19: (openocd)  To flash the software I use openocd :
hacking/flashing.rst:19: (stm)  example for stm-link usb-stick
hacking/flashing.rst:19: (usb)  example for stm-link usb-stick
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (usr)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (sysfsgpio)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (raspberrypi)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (cfg)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (swd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (usr)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (openocd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (cfg)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (bindto)  -c 'bindto 0.0.0.0'
hacking/flashing.rst:32: (openocd)  once you started the openocd background server, you can connect to it using:
hacking/infrastructure.rst:4: (howto)  howto configure gateway
hacking/writeprotection.rst:4: (howto)  howto flash your zephyr image
hacking/writeprotection.rst:26: (howto)  howto remove the write protection
hacking/writeprotection.rst:29: (dap)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:34: (Orangepi)  There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won't need an external programmer at all)
hacking/writeprotection.rst:34: (Openocd)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (cmsis)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (dap)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:38: (dap)  > nrf52.dap apreg 1 0x04 0x01
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/watchdog.rst:25: (fota)  if it cannot feed the watchdog, reset to fota, and you can upload another better version ...
drivers/bma421.rst:36: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:42: (Kconfig)  adapt Kconfig
drivers/bma421.rst:44: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:49: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/bma421.rst:49: (cp)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:53: (KConfig)  edit KConfig
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma280/Kconfig"
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma421/Kconfig"
drivers/bma421.rst:58: (bmc)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (magn)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (Kconfig)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:60: (bme)  source "drivers/sensor/bme280/Kconfig"
drivers/bma421.rst:60: (Kconfig)  source "drivers/sensor/bme280/Kconfig"
drivers/hrs3300.rst:26: (arduino)  I have used the settings of an arduino port of this library.
drivers/hrs3300.rst:38: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:38: (subdirectory)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:38: (ifdef)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:43: (Kconfig)  adapt Kconfig
drivers/hrs3300.rst:45: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:50: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/hrs3300.rst:50: (hx)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:50: (yaml)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:54: (KConfig)  edit KConfig
drivers/hrs3300.rst:56: (Kconfig)  source "drivers/sensor/hrs3300/Kconfig"
drivers/hrs3300.rst:98: (pdf)  HRS3300 Heart Rate Sensor.pdf
drivers/sensors.rst:5: (Accelerometer)  0x18: Accelerometer: BMA423-DS000
drivers/sensors.rst:11: (Hynitron)  0x15: Touch Controller: Hynitron CST816S Touch Controller
drivers/cst816s.rst:7: (hynitron)  the board definition file has been adapted slightly, using the focaltech ft5336 as a touch_controller. A minor change in this driver is enough to get data from the hynitron cst816S.
drivers/cst816s.rst:35: (Hynitron)  the Hynitron cst816s is a touchscreen.
drivers/cst816s.rst:47: (Kconfig)  adapt Kconfig
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/cst816s.rst:81: (lvtouch)  samples/gui/lvtouch (graphical)
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:22: (zephyrproject)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (spi)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (src)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:50: (spi)  complement the pinetime.dts file with the following (under spi)
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/spinor.rst:118: (macronix)  detect ID memory  : it is not the macronix one as suggestion on the pinetime website
drivers/spinor.rst:120: (jedec)  I found the following : jedec-id = [0b 40 16]; (OK: can execute sample program)
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
drivers/battery.rst:25: (adc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  saadc periodical calibration (spec suggests calibration if temperature changes by 10'C)
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (bosch)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:80: (lvaccel)  since no serial port and no J-LINK, I have to print messages to the screen (see sample gui/lvaccel)
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/behind-the-scene.rst:15: (bosch)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/touchscreen.rst:2: (Hynitron)  Touchscreen Hynitron
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:9: (behaviour)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:21: (behaviour)  This affect the behaviour of how threads are handled.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
behind/troubleshoot.rst:35: (threadhandling)  the threadhandling read the I2C-bus
behind/troubleshoot.rst:50: (testirq)  samples/basic/testirq
behind/troubleshoot.rst:65: (Hynitron)  It is based on the Hynitron touchscreen code.
behind/troubleshoot.rst:76: (testsemaphore)  samples/basic/testsemaphore
fota/signing.rst:10: (Bootloader)  The Bootloader is compiled with the public key.
fota/signing.rst:18: (keypair)  Generating a new keypair
fota/signing.rst:19: (keypair)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (keygen)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (subcommand)  subcommand:
fota/signing.rst:32: (keypair)  The generated keypair above contains both the public and the private
fota/signing.rst:32: (bootloader)  bootloader.
fota/signing.rst:47: (rsa)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/partitions.rst:39: (spi)  As the pinetime has an extra spi nor flash chip, we can use this.
fota/smp_svr.rst:12: (mcumgr)  This sample application supports the following mcumgr transports by default:
fota/smp_svr.rst:21: (smp)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:21: (mcumgr)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:23: (mcumgr)  Here is a procedure to install mcumgr on a raspberry pi  (or similar)
fota/smp_svr.rst:38: (smp)  So both slots need smp_svr software!
fota/smp_svr.rst:38: (svr)  So both slots need smp_svr software!
fota/smp_svr.rst:44: (smp)  Step 1: Build smp_svr
fota/smp_svr.rst:44: (svr)  Step 1: Build smp_svr
fota/smp_svr.rst:46: (nRF)   can be built for the nRF52 as follows:
fota/smp_svr.rst:78: (smp)  Step 3: Flash the smp_svr image
fota/smp_svr.rst:78: (svr)  Step 3: Flash the smp_svr image
fota/mcuboot.rst:12: (bootloader)  MCUboot   (a bootloader)
fota/mcuboot.rst:33: (github)  Clone MCUBOOT for zephyr from github.
fota/mcuboot.rst:33: (mcuboot)  Install additional packages required for development with mcuboot:
fota/mcuboot.rst:57: (bootloader)  After building the bootloader, the binaries should reside in
fota/mcuboot.rst:69: (Kconfig)   Kconfig variable, which must be enabled in
fota/mcuboot.rst:74: (bootable)  placement and generation in order for an application to be bootable by
fota/mcuboot.rst:98: (bootloader)  Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.
fota/mcuboot.rst:100: (openocd)  Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)
fota/mcuboot.rst:102: (bootloader)  at which point the bootloader should perform an upgrade.
samples/index.rst:6: (Readme)  In each sample directory is a Readme file.
samples/basic/blinky/README.rst:16: (devicetree)  alias in their board devicetree description file. Doing so will generate
samples/basic/button/README.rst:9: (openocd)  With openocd or any other debugger you can peek at this location.
samples/basic/button/README.rst:26: (sw)  Alternatively, this could also be done by defining 'sw0' alias in the board
samples/basic/button/README.rst:26: (devicetree)  devicetree description file.
samples/basic/touchpoints/README.rst:4: (Touchpoints)  Touchpoints
samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/basic/touchpoints/README.rst:18: (touchpoint)  Only the first touchpoint is usable.
samples/basic/touchpoints/README.rst:26: (howto)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/touchpoints/README.rst:26: (touchpoints)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/scani2c/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/basic/scani2c/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/display/lvgl-posix/README.rst:18: (dev)  this is a posix sample - so no dev board necessary
samples/display/lvgl-posix/README.rst:26: (DCONF)  west build -p -b native_posix_64 samples/display/lvgl -DCONF=board/native-posix_64
samples/display/st7789v/README.rst:14: (grey)  in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (endian)  at any point then the LCD may be endian swapped).
samples/sensor/hrs3300/README.rst:15: (photodiode)  enable the green LED and measure the reflected light with a photodiode. The raw
samples/sensor/bma280/README.rst:4: (Accelerometer)  BMA280: Three Axis High-g I2C/SPI Accelerometer
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/bluetooth/peripheral/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/central_hr/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/eddystone/README.rst:10: (EID)  the definition of how Eddystone-EID beacons are configured and registered with
samples/bluetooth/eddystone/README.rst:20: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/peripheral-cts/README.rst:20: (bluetoothdevice)  a bluetoothdevice running the CTS service
samples/bluetooth/peripheral-cts/README.rst:24: (printk)  You will need a serial port to read the output of the "printk" messages.
samples/gui/clock/README.rst:13: (fn)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/clock/README.rst:13: (src)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/gfx/README.rst:4: (Adafruit)  Adafruit GFX Library on ST7789V Display
samples/gui/gfx/README.rst:9: (Adafruit)  This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.
samples/gui/lvtouch/README.rst:28: (lvtouch)  west build -p -b pinetime samples/gui/lvtouch
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (bosch)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/mgmt/smp_svr/README.rst:13: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_svr/README.rst:28: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_svr/README.rst:34: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_svr/README.rst:48: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_svr/README.rst:56: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_svr/README.rst:60: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_svr/README.rst:91: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:91: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:93: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_svr/README.rst:107: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_svr/README.rst:129: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:129: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:131: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_svr/README.rst:191: (Kconfig)  Kconfig option as described in 
samples/mgmt/smp_wtd/README.rst:19: (smp)  If not, a reset puts it back into smp-server mode, which allows you to upload again.
samples/mgmt/smp_wtd/README.rst:30: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_wtd/README.rst:45: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_wtd/README.rst:51: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_wtd/README.rst:65: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_wtd/README.rst:73: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_wtd/README.rst:77: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_wtd/README.rst:108: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:108: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:110: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_wtd/README.rst:124: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_wtd/README.rst:146: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:146: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:148: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_wtd/README.rst:208: (Kconfig)  Kconfig option as described in 
hacking/latexpdf.rst:2: (howto)  howto generate pdf documents
hacking/latexpdf.rst:2: (pdf)  howto generate pdf documents
hacking/latexpdf.rst:5: (pdf)  sphinx cannot generate pdf directly, and needs latex
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/i2cscanning.rst:54: (endvalue)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/openocd.rst:5: (howto)  howto use 2 openocd sessions
hacking/openocd.rst:5: (openocd)  howto use 2 openocd sessions
hacking/openocd.rst:35: (openocd)  Howto setup a second openocd session on a different port?
hacking/openocd.rst:47: (seperate)  This works really well, and does not require a seperate programmer.
hacking/flashing.rst:12: (swd)  The pinetime has a swd interface.
hacking/flashing.rst:12: (stm)  I use a stm-link which is very cheap(2$).
hacking/flashing.rst:19: (openocd)  To flash the software I use openocd :
hacking/flashing.rst:19: (stm)  example for stm-link usb-stick
hacking/flashing.rst:19: (usb)  example for stm-link usb-stick
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (usr)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (sysfsgpio)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (raspberrypi)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (cfg)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (swd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (usr)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (openocd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (cfg)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (bindto)  -c 'bindto 0.0.0.0'
hacking/flashing.rst:32: (openocd)  once you started the openocd background server, you can connect to it using:
hacking/infrastructure.rst:4: (howto)  howto configure gateway
hacking/writeprotection.rst:4: (howto)  howto flash your zephyr image
hacking/writeprotection.rst:26: (howto)  howto remove the write protection
hacking/writeprotection.rst:29: (dap)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:34: (Orangepi)  There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won't need an external programmer at all)
hacking/writeprotection.rst:34: (Openocd)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (cmsis)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (dap)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:38: (dap)  > nrf52.dap apreg 1 0x04 0x01
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/watchdog.rst:25: (fota)  if it cannot feed the watchdog, reset to fota, and you can upload another better version ...
drivers/bma421.rst:36: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:42: (Kconfig)  adapt Kconfig
drivers/bma421.rst:44: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:49: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/bma421.rst:49: (cp)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:53: (KConfig)  edit KConfig
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma280/Kconfig"
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma421/Kconfig"
drivers/bma421.rst:58: (bmc)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (magn)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (Kconfig)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:60: (bme)  source "drivers/sensor/bme280/Kconfig"
drivers/bma421.rst:60: (Kconfig)  source "drivers/sensor/bme280/Kconfig"
drivers/hrs3300.rst:26: (arduino)  I have used the settings of an arduino port of this library.
drivers/hrs3300.rst:38: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:38: (subdirectory)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:38: (ifdef)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:43: (Kconfig)  adapt Kconfig
drivers/hrs3300.rst:45: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:50: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/hrs3300.rst:50: (hx)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:50: (yaml)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:54: (KConfig)  edit KConfig
drivers/hrs3300.rst:56: (Kconfig)  source "drivers/sensor/hrs3300/Kconfig"
drivers/hrs3300.rst:98: (pdf)  HRS3300 Heart Rate Sensor.pdf
drivers/sensors.rst:5: (Accelerometer)  0x18: Accelerometer: BMA423-DS000
drivers/sensors.rst:11: (Hynitron)  0x15: Touch Controller: Hynitron CST816S Touch Controller
drivers/cst816s.rst:7: (hynitron)  the board definition file has been adapted slightly, using the focaltech ft5336 as a touch_controller. A minor change in this driver is enough to get data from the hynitron cst816S.
drivers/cst816s.rst:35: (Hynitron)  the Hynitron cst816s is a touchscreen.
drivers/cst816s.rst:47: (Kconfig)  adapt Kconfig
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/cst816s.rst:81: (lvtouch)  samples/gui/lvtouch (graphical)
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:22: (zephyrproject)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (spi)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (src)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:50: (spi)  complement the pinetime.dts file with the following (under spi)
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/spinor.rst:118: (macronix)  detect ID memory  : it is not the macronix one as suggestion on the pinetime website
drivers/spinor.rst:120: (jedec)  I found the following : jedec-id = [0b 40 16]; (OK: can execute sample program)
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
drivers/battery.rst:25: (adc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  saadc periodical calibration (spec suggests calibration if temperature changes by 10'C)
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (bosch)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:80: (lvaccel)  since no serial port and no J-LINK, I have to print messages to the screen (see sample gui/lvaccel)
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/behind-the-scene.rst:15: (bosch)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/touchscreen.rst:2: (Hynitron)  Touchscreen Hynitron
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:9: (behaviour)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:21: (behaviour)  This affect the behaviour of how threads are handled.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
behind/troubleshoot.rst:35: (threadhandling)  the threadhandling read the I2C-bus
behind/troubleshoot.rst:50: (testirq)  samples/basic/testirq
behind/troubleshoot.rst:65: (Hynitron)  It is based on the Hynitron touchscreen code.
behind/troubleshoot.rst:76: (testsemaphore)  samples/basic/testsemaphore
fota/signing.rst:10: (Bootloader)  The Bootloader is compiled with the public key.
fota/signing.rst:18: (keypair)  Generating a new keypair
fota/signing.rst:19: (keypair)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (keygen)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (subcommand)  subcommand:
fota/signing.rst:32: (keypair)  The generated keypair above contains both the public and the private
fota/signing.rst:32: (bootloader)  bootloader.
fota/signing.rst:47: (rsa)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/partitions.rst:39: (spi)  As the pinetime has an extra spi nor flash chip, we can use this.
fota/smp_svr.rst:12: (mcumgr)  This sample application supports the following mcumgr transports by default:
fota/smp_svr.rst:21: (smp)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:21: (mcumgr)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:23: (mcumgr)  Here is a procedure to install mcumgr on a raspberry pi  (or similar)
fota/smp_svr.rst:38: (smp)  So both slots need smp_svr software!
fota/smp_svr.rst:38: (svr)  So both slots need smp_svr software!
fota/smp_svr.rst:44: (smp)  Step 1: Build smp_svr
fota/smp_svr.rst:44: (svr)  Step 1: Build smp_svr
fota/smp_svr.rst:46: (nRF)   can be built for the nRF52 as follows:
fota/smp_svr.rst:78: (smp)  Step 3: Flash the smp_svr image
fota/smp_svr.rst:78: (svr)  Step 3: Flash the smp_svr image
fota/mcuboot.rst:12: (bootloader)  MCUboot   (a bootloader)
fota/mcuboot.rst:33: (github)  Clone MCUBOOT for zephyr from github.
fota/mcuboot.rst:33: (mcuboot)  Install additional packages required for development with mcuboot:
fota/mcuboot.rst:57: (bootloader)  After building the bootloader, the binaries should reside in
fota/mcuboot.rst:69: (Kconfig)   Kconfig variable, which must be enabled in
fota/mcuboot.rst:74: (bootable)  placement and generation in order for an application to be bootable by
fota/mcuboot.rst:98: (bootloader)  Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.
fota/mcuboot.rst:100: (openocd)  Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)
fota/mcuboot.rst:102: (bootloader)  at which point the bootloader should perform an upgrade.
samples/index.rst:6: (Readme)  In each sample directory is a Readme file.
samples/basic/blinky/README.rst:16: (devicetree)  alias in their board devicetree description file. Doing so will generate
samples/basic/button/README.rst:9: (openocd)  With openocd or any other debugger you can peek at this location.
samples/basic/button/README.rst:26: (sw)  Alternatively, this could also be done by defining 'sw0' alias in the board
samples/basic/button/README.rst:26: (devicetree)  devicetree description file.
samples/basic/touchpoints/README.rst:4: (Touchpoints)  Touchpoints
samples/basic/touchpoints/README.rst:9: (visable)  it's address 0x15 becomes visable.
samples/basic/touchpoints/README.rst:16: (Cach)  Cach the interrupts and act upon it.
samples/basic/touchpoints/README.rst:18: (touchpoint)  Only the first touchpoint is usable.
samples/basic/touchpoints/README.rst:26: (howto)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/touchpoints/README.rst:26: (touchpoints)  the purpose is just testing howto read the touchpoints of the touchscreen
samples/basic/scani2c/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/basic/scani2c/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/ds6_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Atmel)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/drivers/i2c_scanner/README.rst:12: (Thinkpad)  the Atmel AT24RF08 EEPROM found on many IBM Thinkpad laptops.
samples/display/lvgl-posix/README.rst:9: (buttton)  This sample application displays a buttton on top of the screen
samples/display/lvgl-posix/README.rst:18: (dev)  this is a posix sample - so no dev board necessary
samples/display/lvgl-posix/README.rst:26: (DCONF)  west build -p -b native_posix_64 samples/display/lvgl -DCONF=board/native-posix_64
samples/display/st7789v/README.rst:14: (grey)  in clockwise order, from top left corner: Red, Green, Blue, grey. The shade of
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (grey)  grey changes from black through to white. (if the grey looks too green or red
samples/display/st7789v/README.rst:14: (endian)  at any point then the LCD may be endian swapped).
samples/sensor/hrs3300/README.rst:15: (photodiode)  enable the green LED and measure the reflected light with a photodiode. The raw
samples/sensor/bma280/README.rst:4: (Accelerometer)  BMA280: Three Axis High-g I2C/SPI Accelerometer
samples/sensor/cst816s/README.rst:11: (actived)  This one gets actived by the driver.
samples/bluetooth/peripheral/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/central_hr/README.rst:16: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/eddystone/README.rst:10: (EID)  the definition of how Eddystone-EID beacons are configured and registered with
samples/bluetooth/eddystone/README.rst:20: (BlueZ)  BlueZ running on the host, or
samples/bluetooth/peripheral-cts/README.rst:20: (bluetoothdevice)  a bluetoothdevice running the CTS service
samples/bluetooth/peripheral-cts/README.rst:24: (printk)  You will need a serial port to read the output of the "printk" messages.
samples/gui/clock/README.rst:13: (fn)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/clock/README.rst:13: (src)  Have a look at the test_counter_interrupt_fn function in src/main.c
samples/gui/gfx/README.rst:4: (Adafruit)  Adafruit GFX Library on ST7789V Display
samples/gui/gfx/README.rst:9: (Adafruit)  This is a sample C++ firmware running Adafruit GFX Library on a ST7789V display. The library is ported from Arduino.
samples/gui/lvtouch/README.rst:28: (lvtouch)  west build -p -b pinetime samples/gui/lvtouch
samples/gui/lvaccel/README.rst:4: (accel)  Display accel values
samples/gui/lvaccel/README.rst:12: (bosch)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/gui/lvaccel/README.rst:12: (accel)  It display the values x,y,z from the bosch BMA421 accel sensor.
samples/mgmt/smp_svr/README.rst:13: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_svr/README.rst:28: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_svr/README.rst:34: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_svr/README.rst:48: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_svr/README.rst:56: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_svr/README.rst:60: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_svr/README.rst:91: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:91: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_svr/README.rst:93: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_svr/README.rst:107: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_svr/README.rst:129: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:129: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_svr/README.rst:131: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_svr/README.rst:191: (Kconfig)  Kconfig option as described in 
samples/mgmt/smp_wtd/README.rst:19: (smp)  If not, a reset puts it back into smp-server mode, which allows you to upload again.
samples/mgmt/smp_wtd/README.rst:30: (mcumgr)  This sample application supports the following mcumgr transports by default:
samples/mgmt/smp_wtd/README.rst:45: (nRF)   is configured to run on a Nordic nRF52x MCU. The
samples/mgmt/smp_wtd/README.rst:51: (bootloader)  The MCUboot bootloader is required for 
samples/mgmt/smp_wtd/README.rst:65: (pluggable)  Bluetooth Low Energy (BLE) and do not have a built-in or pluggable BLE radio,
samples/mgmt/smp_wtd/README.rst:73: (nRF)  the Nordic nRF52 Development Kit (
samples/mgmt/smp_wtd/README.rst:77: (nRF)  If you would like to use a more constrained platform, such as the nRF51 DK, you
samples/mgmt/smp_wtd/README.rst:108: (smp)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:108: (svr)  Step 3: Build smp_svr
samples/mgmt/smp_wtd/README.rst:110: (nRF)   can be built for the nRF52 as follows:
samples/mgmt/smp_wtd/README.rst:124: (onwards)  From this section onwards you can use either a binary (
samples/mgmt/smp_wtd/README.rst:146: (smp)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:146: (svr)  Step 5: Flash the smp_svr image
samples/mgmt/smp_wtd/README.rst:148: (nRF)  .  For the nRF52 DK, slot-0 is located at address
samples/mgmt/smp_wtd/README.rst:208: (Kconfig)  Kconfig option as described in 
hacking/latexpdf.rst:2: (howto)  howto generate pdf documents
hacking/latexpdf.rst:2: (pdf)  howto generate pdf documents
hacking/latexpdf.rst:5: (pdf)  sphinx cannot generate pdf directly, and needs latex
hacking/i2cscanning.rst:54: (xC)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/i2cscanning.rst:54: (endvalue)  this corresponds to 0x18, 0x44 and 0xC2 (which is endvalue of scanner, so it does not detect touchscreen, which should be touched first....)
hacking/openocd.rst:5: (howto)  howto use 2 openocd sessions
hacking/openocd.rst:5: (openocd)  howto use 2 openocd sessions
hacking/openocd.rst:35: (openocd)  Howto setup a second openocd session on a different port?
hacking/openocd.rst:47: (seperate)  This works really well, and does not require a seperate programmer.
hacking/flashing.rst:12: (swd)  The pinetime has a swd interface.
hacking/flashing.rst:12: (stm)  I use a stm-link which is very cheap(2$).
hacking/flashing.rst:19: (openocd)  To flash the software I use openocd :
hacking/flashing.rst:19: (stm)  example for stm-link usb-stick
hacking/flashing.rst:19: (usb)  example for stm-link usb-stick
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (usr)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (openocd)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (sysfsgpio)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (raspberrypi)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (cfg)  # openocd -f /usr/local/share/openocd/scripts/interface/sysfsgpio-raspberrypi.cfg
hacking/flashing.rst:28: (swd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (usr)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (openocd)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (cfg)  -c 'transport select swd' -f /usr/local/share/openocd/scripts/target/nrf52.cfg
hacking/flashing.rst:28: (bindto)  -c 'bindto 0.0.0.0'
hacking/flashing.rst:32: (openocd)  once you started the openocd background server, you can connect to it using:
hacking/infrastructure.rst:4: (howto)  howto configure gateway
hacking/writeprotection.rst:4: (howto)  howto flash your zephyr image
hacking/writeprotection.rst:26: (howto)  howto remove the write protection
hacking/writeprotection.rst:29: (dap)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:29: (apreg)  executing the following : nrf52.dap apreg 1 0x0c shows 0x0
hacking/writeprotection.rst:34: (Orangepi)  There is a workaround using the GPIO of a raspberry pi or an Orangepi. (in this case you won't need an external programmer at all)
hacking/writeprotection.rst:34: (Openocd)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (cmsis)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:34: (dap)  You have to reconfigure Openocd with the --enable-cmsis-dap option.
hacking/writeprotection.rst:38: (dap)  > nrf52.dap apreg 1 0x04 0x01
hacking/writeprotection.rst:38: (apreg)  > nrf52.dap apreg 1 0x04 0x01
drivers/watchdog.rst:25: (fota)  if it cannot feed the watchdog, reset to fota, and you can upload another better version ...
drivers/bma421.rst:36: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA280            bma280)
drivers/bma421.rst:36: (subdirectory)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:36: (ifdef)  add_subdirectory_ifdef(CONFIG_BMA421            bma421)
drivers/bma421.rst:42: (Kconfig)  adapt Kconfig
drivers/bma421.rst:44: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/bma421.rst:49: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/bma421.rst:49: (cp)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (bosch)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:49: (yaml)  cp bosch,bma280-i2c.yaml  bosch,bma421-i2c.yaml
drivers/bma421.rst:53: (KConfig)  edit KConfig
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma280/Kconfig"
drivers/bma421.rst:56: (Kconfig)  source "drivers/sensor/bma421/Kconfig"
drivers/bma421.rst:58: (bmc)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (magn)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:58: (Kconfig)  source "drivers/sensor/bmc150_magn/Kconfig"
drivers/bma421.rst:60: (bme)  source "drivers/sensor/bme280/Kconfig"
drivers/bma421.rst:60: (Kconfig)  source "drivers/sensor/bme280/Kconfig"
drivers/hrs3300.rst:26: (arduino)  I have used the settings of an arduino port of this library.
drivers/hrs3300.rst:38: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:38: (subdirectory)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:38: (ifdef)  add_subdirectory_ifdef(CONFIG_HRS3300           hrs3300)
drivers/hrs3300.rst:43: (Kconfig)  adapt Kconfig
drivers/hrs3300.rst:45: (zephyrproject)  ~/zephyrproject-2/zephyr/drivers/sensor
drivers/hrs3300.rst:50: (zephyrproject)  ~/zephyrproject-2/zephyr/dts/bindings/sensor
drivers/hrs3300.rst:50: (hx)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:50: (yaml)  add  hx,hrs3300.yaml
drivers/hrs3300.rst:54: (KConfig)  edit KConfig
drivers/hrs3300.rst:56: (Kconfig)  source "drivers/sensor/hrs3300/Kconfig"
drivers/hrs3300.rst:98: (pdf)  HRS3300 Heart Rate Sensor.pdf
drivers/sensors.rst:5: (Accelerometer)  0x18: Accelerometer: BMA423-DS000
drivers/sensors.rst:11: (Hynitron)  0x15: Touch Controller: Hynitron CST816S Touch Controller
drivers/cst816s.rst:7: (hynitron)  the board definition file has been adapted slightly, using the focaltech ft5336 as a touch_controller. A minor change in this driver is enough to get data from the hynitron cst816S.
drivers/cst816s.rst:35: (Hynitron)  the Hynitron cst816s is a touchscreen.
drivers/cst816s.rst:47: (Kconfig)  adapt Kconfig
drivers/cst816s.rst:54: (Multitouch)  Multitouch is possible, but the screen is small....
drivers/cst816s.rst:81: (lvtouch)  samples/gui/lvtouch (graphical)
drivers/spinor.rst:17: (usefull)  This can be very usefull to store e.g. background for the watch.
drivers/spinor.rst:22: (zephyrproject)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (spi)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:22: (src)  /root/zephyrproject/zephyr/samples/drivers/spi_flash/src/main.c:17:22: error: 'DT_INST_0_JEDEC_SPI_NOR_LABEL' undeclared (first use in this function); did you mean 'DT_INST_0_NORDIC_NRF_RTC_LABEL'?
drivers/spinor.rst:50: (spi)  complement the pinetime.dts file with the following (under spi)
drivers/spinor.rst:50: (xC)  #define JEDEC_ID_MACRONIX_MX25L64      0xC22017
drivers/spinor.rst:118: (macronix)  detect ID memory  : it is not the macronix one as suggestion on the pinetime website
drivers/spinor.rst:120: (jedec)  I found the following : jedec-id = [0b 40 16]; (OK: can execute sample program)
drivers/battery.rst:25: (milivolts)  A module should be able to report battery status in milivolts and charge level in percentage. Additionally, it should notify when external power is connected and when battery is being charged.
drivers/battery.rst:25: (adc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  Module will use adc (saadc peripheral) to measure battery voltage and gpio driver to monitor charge indication pin (pin 0.12) and power presence pin (0.19).
drivers/battery.rst:25: (saadc)  saadc periodical calibration (spec suggests calibration if temperature changes by 10'C)
behind/bma280.rst:5: (accel)  The final goal is to use the accel-sensor in the watch (BMA423), which does not exist yet.
behind/bma280.rst:34: (bosch)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:34: (accel)  This sample application mimics the presence of a bosch, bma280 accel sensor.
behind/bma280.rst:80: (lvaccel)  since no serial port and no J-LINK, I have to print messages to the screen (see sample gui/lvaccel)
behind/behind-the-scene.rst:15: (accel)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/behind-the-scene.rst:15: (bosch)  In case of the accel sensor, I used the bosch bma280 as a template.
behind/lvglbutton.rst:34: (heigh)   the canvas heigh*width eats up RAM and exceeds once > 40
behind/touchscreen.rst:2: (Hynitron)  Touchscreen Hynitron
behind/troubleshoot.rst:5: (accel)  Drivers, like the one for the accel sensor BMA421 or the touchscreen CST816S, can deal with interrupts.
behind/troubleshoot.rst:9: (analysing)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:9: (behaviour)  Even after analysing the behaviour, setting values at each function step, did not get me any further.
behind/troubleshoot.rst:21: (behaviour)  This affect the behaviour of how threads are handled.
behind/troubleshoot.rst:25: (immediatly)  An interrupt is handled immediatly, the processing is offloaded to the threading.
behind/troubleshoot.rst:35: (threadhandling)  the threadhandling read the I2C-bus
behind/troubleshoot.rst:50: (testirq)  samples/basic/testirq
behind/troubleshoot.rst:65: (Hynitron)  It is based on the Hynitron touchscreen code.
behind/troubleshoot.rst:76: (testsemaphore)  samples/basic/testsemaphore
fota/signing.rst:10: (Bootloader)  The Bootloader is compiled with the public key.
fota/signing.rst:18: (keypair)  Generating a new keypair
fota/signing.rst:19: (keypair)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (keygen)  Generating a keypair with imgtool is a matter of running the keygen
fota/signing.rst:19: (subcommand)  subcommand:
fota/signing.rst:32: (keypair)  The generated keypair above contains both the public and the private
fota/signing.rst:32: (bootloader)  bootloader.
fota/signing.rst:47: (rsa)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/signing.rst:47: (pem)  sign the compiled zephyr.bin firmware with the root-rsa-2048.pem, private key:
fota/partitions.rst:39: (spi)  As the pinetime has an extra spi nor flash chip, we can use this.
fota/smp_svr.rst:12: (mcumgr)  This sample application supports the following mcumgr transports by default:
fota/smp_svr.rst:21: (smp)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:21: (mcumgr)  In order to communicate with the smp server sample installed on your pinetime, you need mcumgr.
fota/smp_svr.rst:23: (mcumgr)  Here is a procedure to install mcumgr on a raspberry pi  (or similar)
fota/smp_svr.rst:38: (smp)  So both slots need smp_svr software!
fota/smp_svr.rst:38: (svr)  So both slots need smp_svr software!
fota/smp_svr.rst:44: (smp)  Step 1: Build smp_svr
fota/smp_svr.rst:44: (svr)  Step 1: Build smp_svr
fota/smp_svr.rst:46: (nRF)   can be built for the nRF52 as follows:
fota/smp_svr.rst:78: (smp)  Step 3: Flash the smp_svr image
fota/smp_svr.rst:78: (svr)  Step 3: Flash the smp_svr image
fota/mcuboot.rst:12: (bootloader)  MCUboot   (a bootloader)
fota/mcuboot.rst:33: (github)  Clone MCUBOOT for zephyr from github.
fota/mcuboot.rst:33: (mcuboot)  Install additional packages required for development with mcuboot:
fota/mcuboot.rst:57: (bootloader)  After building the bootloader, the binaries should reside in
fota/mcuboot.rst:69: (Kconfig)   Kconfig variable, which must be enabled in
fota/mcuboot.rst:74: (bootable)  placement and generation in order for an application to be bootable by
fota/mcuboot.rst:98: (bootloader)  Since the bootloader is already in place, you cannot flash your application.bin to 0x00000.
fota/mcuboot.rst:100: (openocd)  Eg. in openocd : program application.bin 0x0c000. (which corresponds to the flash layout of slot 0)
fota/mcuboot.rst:102: (bootloader)  at which point the bootloader should perform an upgrade.
